{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { pie } from 'd3-shape';\nimport { KeyCode } from '../internal/keycode';\nimport { nodeContains } from '../internal/utils/dom';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport ChartPopover from '../internal/components/chart-popover';\nimport SeriesDetails from '../internal/components/chart-series-details';\nimport SeriesMarker from '../internal/components/chart-series-marker';\nimport ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';\nimport InternalBox from '../box/internal';\nimport Labels from './labels';\nimport styles from './styles.css.js';\nimport { defaultDetails, dimensionsBySize, refreshDimensionsBySize } from './utils';\nimport Segments from './segments';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport ChartPlot from '../internal/components/chart-plot';\nexport default (function (_a) {\n  var _b;\n  var _c;\n  var variant = _a.variant,\n    size = _a.size,\n    i18nStrings = _a.i18nStrings,\n    ariaLabel = _a.ariaLabel,\n    ariaLabelledby = _a.ariaLabelledby,\n    data = _a.data,\n    visibleData = _a.visibleData,\n    ariaDescription = _a.ariaDescription,\n    innerMetricValue = _a.innerMetricValue,\n    innerMetricDescription = _a.innerMetricDescription,\n    hideTitles = _a.hideTitles,\n    hideDescriptions = _a.hideDescriptions,\n    detailPopoverContent = _a.detailPopoverContent,\n    detailPopoverSize = _a.detailPopoverSize,\n    width = _a.width,\n    additionalFilters = _a.additionalFilters,\n    hideFilter = _a.hideFilter,\n    hideLegend = _a.hideLegend,\n    statusType = _a.statusType,\n    empty = _a.empty,\n    noMatch = _a.noMatch,\n    errorText = _a.errorText,\n    recoveryText = _a.recoveryText,\n    loadingText = _a.loadingText,\n    onRecoveryClick = _a.onRecoveryClick,\n    segmentDescription = _a.segmentDescription,\n    highlightedSegment = _a.highlightedSegment,\n    onHighlightChange = _a.onHighlightChange,\n    legendSegment = _a.legendSegment,\n    pinnedSegment = _a.pinnedSegment,\n    setPinnedSegment = _a.setPinnedSegment;\n  var plotRef = useRef(null);\n  var containerRef = useRef(null);\n  var focusedSegmentRef = useRef(null);\n  var popoverTrackRef = useRef(null);\n  var isRefresh = useVisualRefresh();\n  var dimensions = isRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];\n  var radius = dimensions.outerRadius;\n  var hasLabels = !(hideTitles && hideDescriptions);\n  var height = 2 * (radius + dimensions.padding + (hasLabels ? dimensions.paddingLabels : 0));\n  // Inner content is only available for donut charts and the inner description is not displayed for small charts\n  var hasInnerContent = variant === 'donut' && (innerMetricValue || innerMetricDescription && size !== 'small');\n  var innerMetricId = useUniqueId('awsui-pie-chart__inner');\n  var _d = useState(false),\n    isTooltipOpen = _d[0],\n    setTooltipOpen = _d[1];\n  var _e = useState(),\n    tooltipData = _e[0],\n    setTooltipData = _e[1];\n  var _f = useMemo(function () {\n      var dataSum = visibleData.reduce(function (sum, d) {\n        return sum + d.datum.value;\n      }, 0);\n      var pieFactory = pie()\n      // Minimum 1% segment size\n      .value(function (d) {\n        return d.datum.value < dataSum / 100 ? dataSum / 100 : d.datum.value;\n      }).sort(null);\n      // Filter out segments with value of zero or below\n      var pieData = pieFactory(visibleData.filter(function (d) {\n        return d.datum.value > 0;\n      }));\n      return {\n        pieData: pieData,\n        dataSum: dataSum\n      };\n    }, [visibleData]),\n    pieData = _f.pieData,\n    dataSum = _f.dataSum;\n  var highlightedSegmentIndex = useMemo(function () {\n    for (var index = 0; index < pieData.length; index++) {\n      if (pieData[index].data.datum === highlightedSegment) {\n        return index;\n      }\n    }\n    return null;\n  }, [pieData, highlightedSegment]);\n  var detailFunction = detailPopoverContent || defaultDetails(i18nStrings);\n  var details = tooltipData ? detailFunction(tooltipData.datum, dataSum) : [];\n  var tooltipContent = tooltipData && React.createElement(SeriesDetails, {\n    details: details\n  });\n  var _g = getChartStatus({\n      externalData: data,\n      visibleData: pieData,\n      statusType: statusType\n    }),\n    isEmpty = _g.isEmpty,\n    showChart = _g.showChart;\n  // Pie charts have a special condition for empty/noMatch due to how zero-value segments are handled.\n  var isNoMatch = isEmpty && visibleData.length !== data.length;\n  var reserveLegendSpace = !showChart && !hideLegend;\n  var reserveFilterSpace = statusType !== 'finished' && !isNoMatch && (!hideFilter || additionalFilters);\n  var popoverDismissedRecently = useRef(false);\n  var highlightSegment = useCallback(function (internalDatum) {\n    var segment = internalDatum.datum;\n    if (segment !== highlightedSegment) {\n      onHighlightChange(segment);\n    }\n    if (popoverTrackRef.current) {\n      setTooltipData({\n        datum: internalDatum.datum,\n        series: {\n          color: internalDatum.color,\n          index: internalDatum.index,\n          label: internalDatum.datum.title,\n          markerType: 'rectangle'\n        },\n        trackRef: popoverTrackRef\n      });\n      setTooltipOpen(true);\n    }\n  }, [highlightedSegment, setTooltipOpen, onHighlightChange]);\n  var clearHighlightedSegment = useCallback(function () {\n    setTooltipOpen(false);\n    onHighlightChange(null);\n  }, [onHighlightChange, setTooltipOpen]);\n  var onClick = useCallback(function (internalDatum) {\n    if (pinnedSegment === internalDatum.datum) {\n      setPinnedSegment(null);\n      clearHighlightedSegment();\n    } else {\n      setPinnedSegment(internalDatum.datum);\n      highlightSegment(internalDatum);\n    }\n  }, [pinnedSegment, clearHighlightedSegment, setPinnedSegment, highlightSegment]);\n  var onMouseOver = useCallback(function (internalDatum) {\n    if (pinnedSegment !== null) {\n      return;\n    }\n    highlightSegment(internalDatum);\n  }, [pinnedSegment, highlightSegment]);\n  var onMouseOut = useCallback(function () {\n    if (pinnedSegment !== null) {\n      return;\n    }\n    clearHighlightedSegment();\n  }, [pinnedSegment, clearHighlightedSegment]);\n  var onKeyDown = useCallback(function (event) {\n    if (event.keyCode !== KeyCode.right && event.keyCode !== KeyCode.left && event.keyCode !== KeyCode.enter) {\n      return;\n    }\n    event.preventDefault();\n    var nextIndex = highlightedSegmentIndex || 0;\n    var MAX = pieData.length - 1;\n    if (event.keyCode === KeyCode.right) {\n      nextIndex++;\n      if (nextIndex > MAX) {\n        nextIndex = 0;\n      }\n    } else if (event.keyCode === KeyCode.left) {\n      nextIndex--;\n      if (nextIndex < 0) {\n        nextIndex = MAX;\n      }\n    }\n    if (event.keyCode === KeyCode.enter) {\n      setPinnedSegment(pieData[nextIndex].data.datum);\n    }\n    highlightSegment(pieData[nextIndex].data);\n  }, [setPinnedSegment, highlightSegment, pieData, highlightedSegmentIndex]);\n  var onFocus = useCallback(function (_event, target) {\n    // We need to make sure that we do not re-show the popover when we focus the segment after the popover is dismissed.\n    // Normally we would check `event.relatedTarget` for the previously focused element,\n    // but this is not supported for SVG elements in IE11. The workaround is this `popoverDismissedRecently` ref.\n    if (pinnedSegment !== null || popoverDismissedRecently.current || target === 'mouse') {\n      return;\n    }\n    var segment = highlightedSegment || legendSegment || pieData[0].data.datum;\n    var matched = pieData.filter(function (d) {\n      return d.data.datum === segment;\n    });\n    highlightSegment(matched[0].data);\n  }, [pinnedSegment, pieData, highlightSegment, highlightedSegment, legendSegment]);\n  var onBlur = useCallback(function (event) {\n    var blurTarget = event.relatedTarget || event.target;\n    if (blurTarget === null || !(blurTarget instanceof Element) || !nodeContains(containerRef.current, blurTarget)) {\n      // We only need to close the tooltip and remove the pinned segment so that we keep track of the current\n      // highlighted legendSeries. using clearHighlightedSegment() would set the legendSeries to null, in that case\n      // using Keyboard Tab will always highlight the first legend item in the legend component.\n      setTooltipOpen(false);\n      setPinnedSegment(null);\n    }\n  }, [setPinnedSegment]);\n  var onPopoverDismiss = function (outsideClick) {\n    setTooltipOpen(false);\n    setPinnedSegment(null);\n    if (!outsideClick) {\n      // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n      setTimeout(function () {\n        popoverDismissedRecently.current = true;\n        plotRef.current.focusApplication();\n        popoverDismissedRecently.current = false;\n      }, 0);\n    }\n  };\n  return React.createElement(\"div\", {\n    className: clsx(styles.content, styles[\"content--\".concat(size)], (_b = {}, _b[styles['content--without-labels']] = !hasLabels, _b[styles['content--reserve-filter']] = reserveFilterSpace, _b[styles['content--reserve-legend']] = reserveLegendSpace, _b))\n  }, React.createElement(ChartStatusContainer, {\n    isEmpty: isEmpty,\n    isNoMatch: isNoMatch,\n    showChart: showChart,\n    statusType: statusType,\n    empty: empty,\n    noMatch: noMatch,\n    loadingText: loadingText,\n    errorText: errorText,\n    recoveryText: recoveryText,\n    onRecoveryClick: onRecoveryClick\n  }), showChart && React.createElement(\"div\", {\n    className: styles['chart-container'],\n    ref: containerRef\n  }, React.createElement(ChartPlot, {\n    ref: plotRef,\n    width: width,\n    height: height,\n    transform: \"translate(\".concat(width / 2, \" \").concat(height / 2, \")\"),\n    isPrecise: true,\n    isClickable: !isTooltipOpen,\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    ariaDescription: ariaDescription,\n    ariaDescribedby: hasInnerContent ? innerMetricId : undefined,\n    ariaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.chartAriaRoleDescription,\n    ariaLiveRegion: tooltipContent,\n    activeElementRef: focusedSegmentRef,\n    activeElementKey: highlightedSegmentIndex === null || highlightedSegmentIndex === void 0 ? void 0 : highlightedSegmentIndex.toString(),\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onKeyDown: onKeyDown\n  }, React.createElement(Segments, {\n    pieData: pieData,\n    size: size,\n    variant: variant,\n    focusedSegmentRef: focusedSegmentRef,\n    popoverTrackRef: popoverTrackRef,\n    highlightedSegment: highlightedSegment,\n    segmentAriaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.segmentAriaRoleDescription,\n    onClick: onClick,\n    onMouseOver: onMouseOver,\n    onMouseOut: onMouseOut\n  }), hasLabels && React.createElement(Labels, {\n    pieData: pieData,\n    size: size,\n    segmentDescription: segmentDescription,\n    visibleDataSum: dataSum,\n    hideTitles: hideTitles,\n    hideDescriptions: hideDescriptions,\n    highlightedSegment: highlightedSegment,\n    containerRef: containerRef\n  })), hasInnerContent && React.createElement(\"div\", {\n    className: styles['inner-content'],\n    id: innerMetricId\n  }, innerMetricValue && React.createElement(InternalBox, {\n    variant: size === 'small' ? 'h3' : 'h1',\n    tagOverride: \"div\",\n    color: \"inherit\",\n    padding: \"n\"\n  }, innerMetricValue), innerMetricDescription && size !== 'small' && React.createElement(InternalBox, {\n    variant: \"h3\",\n    color: \"text-body-secondary\",\n    tagOverride: \"div\",\n    padding: \"n\"\n  }, innerMetricDescription)), isTooltipOpen && tooltipData && React.createElement(ChartPopover, {\n    title: tooltipData.series && React.createElement(InternalBox, {\n      className: styles['popover-header'],\n      variant: \"strong\"\n    }, React.createElement(SeriesMarker, {\n      color: tooltipData.series.color,\n      type: tooltipData.series.markerType\n    }), ' ', tooltipData.series.label),\n    trackRef: tooltipData.trackRef,\n    trackKey: tooltipData.series.index,\n    dismissButton: pinnedSegment !== null,\n    dismissAriaLabel: i18nStrings.detailPopoverDismissAriaLabel,\n    onDismiss: onPopoverDismiss,\n    container: ((_c = plotRef.current) === null || _c === void 0 ? void 0 : _c.svg) || null,\n    size: detailPopoverSize\n  }, tooltipContent)));\n});","map":{"version":3,"mappings":"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","names":["React","useCallback","useMemo","useRef","useState","clsx","pie","KeyCode","nodeContains","useUniqueId","ChartPopover","SeriesDetails","SeriesMarker","ChartStatusContainer","getChartStatus","InternalBox","Labels","styles","defaultDetails","dimensionsBySize","refreshDimensionsBySize","Segments","useVisualRefresh","ChartPlot","_a","variant","size","i18nStrings","ariaLabel","ariaLabelledby","data","visibleData","ariaDescription","innerMetricValue","innerMetricDescription","hideTitles","hideDescriptions","detailPopoverContent","detailPopoverSize","width","additionalFilters","hideFilter","hideLegend","statusType","empty","noMatch","errorText","recoveryText","loadingText","onRecoveryClick","segmentDescription","highlightedSegment","onHighlightChange","legendSegment","pinnedSegment","setPinnedSegment","plotRef","containerRef","focusedSegmentRef","popoverTrackRef","isRefresh","dimensions","radius","outerRadius","hasLabels","height","padding","paddingLabels","hasInnerContent","innerMetricId","isTooltipOpen","setTooltipOpen","tooltipData","setTooltipData","dataSum","reduce","sum","d","datum","value","pieFactory","sort","pieData","filter","highlightedSegmentIndex","index","length","detailFunction","details","tooltipContent","externalData","isEmpty","showChart","isNoMatch","reserveLegendSpace","reserveFilterSpace","popoverDismissedRecently","highlightSegment","internalDatum","segment","current","series","color","label","title","markerType","trackRef","clearHighlightedSegment","onClick","onMouseOver","onMouseOut","onKeyDown","event","keyCode","right","left","enter","preventDefault","nextIndex","MAX","onFocus","_event","target","matched","onBlur","blurTarget","relatedTarget","Element","onPopoverDismiss","outsideClick","setTimeout","focusApplication","className","content","_b","ref","transform","isPrecise","isClickable","ariaDescribedby","undefined","ariaRoleDescription","chartAriaRoleDescription","ariaLiveRegion","activeElementRef","activeElementKey","toString","segmentAriaRoleDescription","visibleDataSum","id","tagOverride","type","trackKey","dismissButton","dismissAriaLabel","detailPopoverDismissAriaLabel","onDismiss","container","svg"],"sources":["/Users/dcastro/node_modules/src/pie-chart/pie-chart.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { pie } from 'd3-shape';\n\nimport { KeyCode } from '../internal/keycode';\nimport { nodeContains } from '../internal/utils/dom';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport ChartPopover from '../internal/components/chart-popover';\nimport SeriesDetails from '../internal/components/chart-series-details';\nimport SeriesMarker from '../internal/components/chart-series-marker';\nimport ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';\nimport InternalBox from '../box/internal';\n\nimport Labels from './labels';\nimport { PieChartProps, SeriesInfo } from './interfaces';\nimport styles from './styles.css.js';\nimport { defaultDetails, dimensionsBySize, refreshDimensionsBySize } from './utils';\nimport Segments from './segments';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport ChartPlot, { ChartPlotRef } from '../internal/components/chart-plot';\nimport { SomeRequired } from '../internal/types';\n\nexport interface InternalChartDatum<T> {\n  index: number;\n  color: string;\n  datum: Readonly<T>;\n}\n\ninterface InternalPieChartProps<T extends PieChartProps.Datum>\n  extends SomeRequired<\n    Omit<PieChartProps<T>, 'onHighlightChange'>,\n    'variant' | 'size' | 'i18nStrings' | 'hideTitles' | 'hideDescriptions' | 'statusType'\n  > {\n  visibleData: Array<InternalChartDatum<T>>;\n  width: number;\n\n  highlightedSegment: T | null;\n  onHighlightChange: (segment: null | T) => void;\n\n  legendSegment: T | null;\n\n  pinnedSegment: T | null;\n  setPinnedSegment: React.Dispatch<React.SetStateAction<T | null>>;\n}\n\nexport interface TooltipData<T> {\n  datum: T;\n  trackRef: React.RefObject<SVGElement>;\n  series: SeriesInfo;\n}\n\nexport default <T extends PieChartProps.Datum>({\n  variant,\n  size,\n  i18nStrings,\n  ariaLabel,\n  ariaLabelledby,\n  data,\n  visibleData,\n  ariaDescription,\n  innerMetricValue,\n  innerMetricDescription,\n  hideTitles,\n  hideDescriptions,\n  detailPopoverContent,\n  detailPopoverSize,\n  width,\n  additionalFilters,\n  hideFilter,\n  hideLegend,\n  statusType,\n  empty,\n  noMatch,\n  errorText,\n  recoveryText,\n  loadingText,\n  onRecoveryClick,\n  segmentDescription,\n  highlightedSegment,\n  onHighlightChange,\n  legendSegment,\n  pinnedSegment,\n  setPinnedSegment,\n}: InternalPieChartProps<T>) => {\n  const plotRef = useRef<ChartPlotRef>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const focusedSegmentRef = useRef<SVGGElement>(null);\n  const popoverTrackRef = useRef<SVGCircleElement>(null);\n  const isRefresh = useVisualRefresh();\n\n  const dimensions = isRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];\n  const radius = dimensions.outerRadius;\n\n  const hasLabels = !(hideTitles && hideDescriptions);\n  const height = 2 * (radius + dimensions.padding + (hasLabels ? dimensions.paddingLabels : 0));\n\n  // Inner content is only available for donut charts and the inner description is not displayed for small charts\n  const hasInnerContent = variant === 'donut' && (innerMetricValue || (innerMetricDescription && size !== 'small'));\n\n  const innerMetricId = useUniqueId('awsui-pie-chart__inner');\n\n  const [isTooltipOpen, setTooltipOpen] = useState<boolean>(false);\n  const [tooltipData, setTooltipData] = useState<TooltipData<T>>();\n\n  const { pieData, dataSum } = useMemo(() => {\n    const dataSum = visibleData.reduce((sum, d) => sum + d.datum.value, 0);\n\n    const pieFactory = pie<InternalChartDatum<T>>()\n      // Minimum 1% segment size\n      .value(d => (d.datum.value < dataSum / 100 ? dataSum / 100 : d.datum.value))\n      .sort(null);\n\n    // Filter out segments with value of zero or below\n    const pieData = pieFactory(visibleData.filter(d => d.datum.value > 0));\n\n    return { pieData, dataSum };\n  }, [visibleData]);\n\n  const highlightedSegmentIndex = useMemo(() => {\n    for (let index = 0; index < pieData.length; index++) {\n      if (pieData[index].data.datum === highlightedSegment) {\n        return index;\n      }\n    }\n    return null;\n  }, [pieData, highlightedSegment]);\n\n  const detailFunction = detailPopoverContent || defaultDetails(i18nStrings);\n  const details = tooltipData ? detailFunction(tooltipData.datum, dataSum) : [];\n  const tooltipContent = tooltipData && <SeriesDetails details={details} />;\n\n  const { isEmpty, showChart } = getChartStatus({ externalData: data, visibleData: pieData, statusType });\n\n  // Pie charts have a special condition for empty/noMatch due to how zero-value segments are handled.\n  const isNoMatch = isEmpty && visibleData.length !== data.length;\n\n  const reserveLegendSpace = !showChart && !hideLegend;\n  const reserveFilterSpace = statusType !== 'finished' && !isNoMatch && (!hideFilter || additionalFilters);\n\n  const popoverDismissedRecently = useRef(false);\n\n  const highlightSegment = useCallback(\n    (internalDatum: InternalChartDatum<T>) => {\n      const segment = internalDatum.datum;\n      if (segment !== highlightedSegment) {\n        onHighlightChange(segment);\n      }\n\n      if (popoverTrackRef.current) {\n        setTooltipData({\n          datum: internalDatum.datum,\n          series: {\n            color: internalDatum.color,\n            index: internalDatum.index,\n            label: internalDatum.datum.title,\n            markerType: 'rectangle',\n          },\n          trackRef: popoverTrackRef,\n        });\n        setTooltipOpen(true);\n      }\n    },\n    [highlightedSegment, setTooltipOpen, onHighlightChange]\n  );\n  const clearHighlightedSegment = useCallback(() => {\n    setTooltipOpen(false);\n    onHighlightChange(null);\n  }, [onHighlightChange, setTooltipOpen]);\n\n  const onClick = useCallback(\n    (internalDatum: InternalChartDatum<T>) => {\n      if (pinnedSegment === internalDatum.datum) {\n        setPinnedSegment(null);\n        clearHighlightedSegment();\n      } else {\n        setPinnedSegment(internalDatum.datum);\n        highlightSegment(internalDatum);\n      }\n    },\n    [pinnedSegment, clearHighlightedSegment, setPinnedSegment, highlightSegment]\n  );\n  const onMouseOver = useCallback(\n    (internalDatum: InternalChartDatum<T>) => {\n      if (pinnedSegment !== null) {\n        return;\n      }\n      highlightSegment(internalDatum);\n    },\n    [pinnedSegment, highlightSegment]\n  );\n  const onMouseOut = useCallback(() => {\n    if (pinnedSegment !== null) {\n      return;\n    }\n\n    clearHighlightedSegment();\n  }, [pinnedSegment, clearHighlightedSegment]);\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      if (event.keyCode !== KeyCode.right && event.keyCode !== KeyCode.left && event.keyCode !== KeyCode.enter) {\n        return;\n      }\n\n      event.preventDefault();\n\n      let nextIndex = highlightedSegmentIndex || 0;\n      const MAX = pieData.length - 1;\n      if (event.keyCode === KeyCode.right) {\n        nextIndex++;\n        if (nextIndex > MAX) {\n          nextIndex = 0;\n        }\n      } else if (event.keyCode === KeyCode.left) {\n        nextIndex--;\n        if (nextIndex < 0) {\n          nextIndex = MAX;\n        }\n      }\n      if (event.keyCode === KeyCode.enter) {\n        setPinnedSegment(pieData[nextIndex].data.datum);\n      }\n      highlightSegment(pieData[nextIndex].data);\n    },\n    [setPinnedSegment, highlightSegment, pieData, highlightedSegmentIndex]\n  );\n  const onFocus = useCallback(\n    (_event: any, target: 'keyboard' | 'mouse') => {\n      // We need to make sure that we do not re-show the popover when we focus the segment after the popover is dismissed.\n      // Normally we would check `event.relatedTarget` for the previously focused element,\n      // but this is not supported for SVG elements in IE11. The workaround is this `popoverDismissedRecently` ref.\n      if (pinnedSegment !== null || popoverDismissedRecently.current || target === 'mouse') {\n        return;\n      }\n\n      const segment = highlightedSegment || legendSegment || pieData[0].data.datum;\n      const matched = pieData.filter(d => d.data.datum === segment);\n      highlightSegment(matched[0].data);\n    },\n    [pinnedSegment, pieData, highlightSegment, highlightedSegment, legendSegment]\n  );\n\n  const onBlur = useCallback(\n    (event: React.FocusEvent) => {\n      const blurTarget = event.relatedTarget || event.target;\n      if (blurTarget === null || !(blurTarget instanceof Element) || !nodeContains(containerRef.current, blurTarget)) {\n        // We only need to close the tooltip and remove the pinned segment so that we keep track of the current\n        // highlighted legendSeries. using clearHighlightedSegment() would set the legendSeries to null, in that case\n        // using Keyboard Tab will always highlight the first legend item in the legend component.\n        setTooltipOpen(false);\n        setPinnedSegment(null);\n      }\n    },\n    [setPinnedSegment]\n  );\n  const onPopoverDismiss = (outsideClick?: boolean) => {\n    setTooltipOpen(false);\n    setPinnedSegment(null);\n\n    if (!outsideClick) {\n      // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n      setTimeout(() => {\n        popoverDismissedRecently.current = true;\n        plotRef.current!.focusApplication();\n        popoverDismissedRecently.current = false;\n      }, 0);\n    }\n  };\n\n  return (\n    <div\n      className={clsx(styles.content, styles[`content--${size}`], {\n        [styles['content--without-labels']]: !hasLabels,\n        [styles['content--reserve-filter']]: reserveFilterSpace,\n        [styles['content--reserve-legend']]: reserveLegendSpace,\n      })}\n    >\n      <ChartStatusContainer\n        isEmpty={isEmpty}\n        isNoMatch={isNoMatch}\n        showChart={showChart}\n        statusType={statusType}\n        empty={empty}\n        noMatch={noMatch}\n        loadingText={loadingText}\n        errorText={errorText}\n        recoveryText={recoveryText}\n        onRecoveryClick={onRecoveryClick}\n      />\n      {showChart && (\n        <div className={styles['chart-container']} ref={containerRef}>\n          <ChartPlot\n            ref={plotRef}\n            width={width}\n            height={height}\n            transform={`translate(${width / 2} ${height / 2})`}\n            isPrecise={true}\n            isClickable={!isTooltipOpen}\n            ariaLabel={ariaLabel}\n            ariaLabelledby={ariaLabelledby}\n            ariaDescription={ariaDescription}\n            ariaDescribedby={hasInnerContent ? innerMetricId : undefined}\n            ariaRoleDescription={i18nStrings?.chartAriaRoleDescription}\n            ariaLiveRegion={tooltipContent}\n            activeElementRef={focusedSegmentRef}\n            activeElementKey={highlightedSegmentIndex?.toString()}\n            onFocus={onFocus}\n            onBlur={onBlur}\n            onKeyDown={onKeyDown}\n          >\n            <Segments\n              pieData={pieData}\n              size={size}\n              variant={variant}\n              focusedSegmentRef={focusedSegmentRef}\n              popoverTrackRef={popoverTrackRef}\n              highlightedSegment={highlightedSegment}\n              segmentAriaRoleDescription={i18nStrings?.segmentAriaRoleDescription}\n              onClick={onClick}\n              onMouseOver={onMouseOver}\n              onMouseOut={onMouseOut}\n            />\n            {hasLabels && (\n              <Labels\n                pieData={pieData}\n                size={size}\n                segmentDescription={segmentDescription}\n                visibleDataSum={dataSum}\n                hideTitles={hideTitles}\n                hideDescriptions={hideDescriptions}\n                highlightedSegment={highlightedSegment}\n                containerRef={containerRef}\n              />\n            )}\n          </ChartPlot>\n          {hasInnerContent && (\n            <div className={styles['inner-content']} id={innerMetricId}>\n              {innerMetricValue && (\n                <InternalBox variant={size === 'small' ? 'h3' : 'h1'} tagOverride=\"div\" color=\"inherit\" padding=\"n\">\n                  {innerMetricValue}\n                </InternalBox>\n              )}\n              {innerMetricDescription && size !== 'small' && (\n                <InternalBox variant=\"h3\" color=\"text-body-secondary\" tagOverride=\"div\" padding=\"n\">\n                  {innerMetricDescription}\n                </InternalBox>\n              )}\n            </div>\n          )}\n          {isTooltipOpen && tooltipData && (\n            <ChartPopover\n              title={\n                tooltipData.series && (\n                  <InternalBox className={styles['popover-header']} variant=\"strong\">\n                    <SeriesMarker color={tooltipData.series.color} type={tooltipData.series.markerType} />{' '}\n                    {tooltipData.series.label}\n                  </InternalBox>\n                )\n              }\n              trackRef={tooltipData.trackRef}\n              trackKey={tooltipData.series.index}\n              dismissButton={pinnedSegment !== null}\n              dismissAriaLabel={i18nStrings.detailPopoverDismissAriaLabel}\n              onDismiss={onPopoverDismiss}\n              container={plotRef.current?.svg || null}\n              size={detailPopoverSize}\n            >\n              {tooltipContent}\n            </ChartPopover>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}