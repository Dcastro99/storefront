{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useState } from 'react';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { Flash } from './flash';\nimport { getBaseProps } from '../internal/base-component';\nimport InternalIcon from '../icon/internal';\nimport { TIMEOUT_FOR_ENTERING_ANIMATION } from './constant';\nimport { TransitionGroup } from 'react-transition-group';\nimport { Transition } from '../internal/components/transition';\nimport useBaseComponent from '../internal/hooks/use-base-component';\nimport { useContainerBreakpoints } from '../internal/hooks/container-queries';\nimport useFocusVisible from '../internal/hooks/focus-visible';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { useReducedMotion, useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { getVisualContextClassname } from '../internal/components/visual-context';\nimport styles from './styles.css.js';\nexport default function Flashbar(_a) {\n  var items = _a.items,\n    restProps = __rest(_a, [\"items\"]);\n  var __internalRootRef = useBaseComponent('Flashbar').__internalRootRef;\n  var _b = useContainerBreakpoints(['xs']),\n    breakpoint = _b[0],\n    ref = _b[1];\n  var baseProps = getBaseProps(restProps);\n  var mergedRef = useMergeRefs(ref, __internalRootRef);\n  var isFocusVisible = useFocusVisible();\n  var isVisualRefresh = useVisualRefresh();\n  /**\n   * All the flash items should have ids so we can identify which DOM element is being\n   * removed from the DOM to animate it. Motion will be disabled if any of the provided\n   * flash messages does not contain an `id`.\n   */\n  var motionDisabled = useReducedMotion(ref) || !isVisualRefresh || items && !items.every(function (item) {\n    return 'id' in item;\n  });\n  /**\n   * The `stackItems` property is a hidden boolean that allows for teams\n   * to beta test the flashbar stacking feature.\n   */\n  var stackItems = restProps.stackItems;\n  var ariaLabels = restProps.ariaLabels;\n  var isFlashbarStacked = stackItems && (items === null || items === void 0 ? void 0 : items.length) > 3;\n  var _c = useState(false),\n    isFlashbarStackExpanded = _c[0],\n    setIsFlashbarStackExpanded = _c[1];\n  /**\n   * Compute the appropriate aria label for the stacked notifications toggle button\n   * based on the expanded/collapsed state of the stack and the presence of\n   * corresponding aria label properties.\n   */\n  function getStackButtonAriaLabel() {\n    var _a, _b;\n    var stackButtonAriaLabel;\n    if (isFlashbarStackExpanded) {\n      stackButtonAriaLabel = (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.stackCollapseLabel) !== null && _a !== void 0 ? _a : 'Collapse stacked notifications';\n    } else {\n      stackButtonAriaLabel = (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.stackExpandLabel) !== null && _b !== void 0 ? _b : 'Expand stacked notifications';\n    }\n    return stackButtonAriaLabel;\n  }\n  /**\n   * If the `isFlashbarStacked` is true (which is only possible if `stackItems` is true)\n   * then the first item should be rendered followed by two dummy items that visually indicate\n   * two, three, or more items exist in the stack.\n   */\n  function renderStackedItems() {\n    var _a;\n    if (!isFlashbarStacked) {\n      return;\n    }\n    var stackDepth = Math.min(3, items.length);\n    var stackedItems = items.slice(0, stackDepth);\n    return React.createElement(\"div\", {\n      className: styles.stack,\n      style: (_a = {}, _a[customCssProps.flashbarStackDepth] = stackDepth, _a)\n    }, !isFlashbarStackExpanded && React.createElement(\"div\", {\n      className: clsx(styles.collapsed, isVisualRefresh && styles['visual-refresh'])\n    }, stackedItems.map(function (item, index) {\n      var _a;\n      var _b, _c;\n      return React.createElement(\"div\", {\n        className: styles.item,\n        style: (_a = {}, _a[customCssProps.flashbarStackIndex] = index, _a),\n        key: index\n      }, index === 0 && renderItem(item, (_b = item.id) !== null && _b !== void 0 ? _b : index), index > 0 && React.createElement(\"div\", {\n        className: clsx(styles.flash, styles[\"flash-type-\".concat((_c = item.type) !== null && _c !== void 0 ? _c : 'info')])\n      }));\n    })), isFlashbarStackExpanded && React.createElement(\"div\", {\n      className: styles.expanded\n    }, items.map(function (item, index) {\n      var _a;\n      return renderItem(item, (_a = item.id) !== null && _a !== void 0 ? _a : index);\n    })), React.createElement(\"button\", __assign({\n      \"aria-label\": getStackButtonAriaLabel(),\n      className: clsx(styles.toggle, isVisualRefresh && styles['visual-refresh']),\n      onClick: function () {\n        return setIsFlashbarStackExpanded(!isFlashbarStackExpanded);\n      }\n    }, isFocusVisible), React.createElement(InternalIcon, {\n      className: clsx(styles.icon, isFlashbarStackExpanded && styles.expanded),\n      size: \"small\",\n      name: \"angle-down\"\n    })));\n  }\n  /**\n   * If the flashbar is flat and motion is `enabled` then the adding and removing of items\n   * from the flashbar will render with visual transitions.\n   */\n  function renderFlatItemsWithTransitions() {\n    if (isFlashbarStacked || motionDisabled || !items) {\n      return;\n    }\n    return React.createElement(TransitionGroup, {\n      component: null\n    }, items && items.map(function (item, index) {\n      var _a;\n      return React.createElement(Transition, {\n        transitionChangeDelay: {\n          entering: TIMEOUT_FOR_ENTERING_ANIMATION\n        },\n        key: (_a = item.id) !== null && _a !== void 0 ? _a : index,\n        \"in\": true\n      }, function (state, transitionRootElement) {\n        var _a;\n        return renderItem(item, (_a = item.id) !== null && _a !== void 0 ? _a : index, transitionRootElement, state);\n      });\n    }));\n  }\n  /**\n   * If the flashbar is flat and motion is `disabled` then the adding and removing of items\n   * from the flashbar will render without visual transitions.\n   */\n  function renderFlatItemsWithoutTransitions() {\n    if (isFlashbarStacked || !motionDisabled || !items) {\n      return;\n    }\n    return React.createElement(React.Fragment, null, items.map(function (item, index) {\n      var _a;\n      return renderItem(item, (_a = item.id) !== null && _a !== void 0 ? _a : index);\n    }));\n  }\n  /**\n   * This is a shared render function for a single flashbar item to be used\n   * by the stacking, motion, and non-motion item group render functions.\n   */\n  function renderItem(item, key, transitionRootElement, transitionState) {\n    return React.createElement(Flash\n    // eslint-disable-next-line react/forbid-component-props\n    , __assign({\n      // eslint-disable-next-line react/forbid-component-props\n      className: clsx(getVisualContextClassname('flashbar'), isVisualRefresh ? styles['flash-refresh'] : ''),\n      key: key,\n      ref: transitionRootElement,\n      transitionState: transitionState\n    }, item));\n  }\n  return React.createElement(\"div\", __assign({}, baseProps, {\n    className: clsx(baseProps.className, styles.flashbar, styles[\"breakpoint-\".concat(breakpoint)]),\n    ref: mergedRef\n  }), renderStackedItems(), renderFlatItemsWithTransitions(), renderFlatItemsWithoutTransitions());\n}\napplyDisplayName(Flashbar, 'Flashbar');","map":{"version":3,"mappings":"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","names":["clsx","React","useState","applyDisplayName","customCssProps","Flash","getBaseProps","InternalIcon","TIMEOUT_FOR_ENTERING_ANIMATION","TransitionGroup","Transition","useBaseComponent","useContainerBreakpoints","useFocusVisible","useMergeRefs","useReducedMotion","useVisualRefresh","getVisualContextClassname","styles","Flashbar","_a","restProps","breakpoint","ref","baseProps","mergedRef","__internalRootRef","isFocusVisible","isVisualRefresh","motionDisabled","items","every","item","stackItems","ariaLabels","isFlashbarStacked","length","isFlashbarStackExpanded","setIsFlashbarStackExpanded","getStackButtonAriaLabel","stackButtonAriaLabel","stackCollapseLabel","stackExpandLabel","renderStackedItems","stackDepth","Math","min","stackedItems","slice","className","stack","style","flashbarStackDepth","collapsed","map","index","flashbarStackIndex","key","renderItem","id","flash","type","expanded","toggle","onClick","icon","size","name","renderFlatItemsWithTransitions","component","transitionChangeDelay","entering","state","transitionRootElement","renderFlatItemsWithoutTransitions","transitionState","flashbar"],"sources":["/Users/dcastro/node_modules/src/flashbar/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useState } from 'react';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { Flash } from './flash';\nimport { FlashbarProps } from './interfaces';\nimport { getBaseProps } from '../internal/base-component';\nimport InternalIcon from '../icon/internal';\nimport { TIMEOUT_FOR_ENTERING_ANIMATION } from './constant';\nimport { TransitionGroup } from 'react-transition-group';\nimport { Transition } from '../internal/components/transition';\nimport useBaseComponent from '../internal/hooks/use-base-component';\nimport { useContainerBreakpoints } from '../internal/hooks/container-queries';\nimport useFocusVisible from '../internal/hooks/focus-visible';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { useReducedMotion, useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { getVisualContextClassname } from '../internal/components/visual-context';\nimport styles from './styles.css.js';\n\nexport { FlashbarProps };\n\nexport default function Flashbar({ items, ...restProps }: FlashbarProps) {\n  const { __internalRootRef } = useBaseComponent('Flashbar');\n  const [breakpoint, ref] = useContainerBreakpoints(['xs']);\n  const baseProps = getBaseProps(restProps);\n  const mergedRef = useMergeRefs(ref, __internalRootRef);\n  const isFocusVisible = useFocusVisible();\n  const isVisualRefresh = useVisualRefresh();\n\n  /**\n   * All the flash items should have ids so we can identify which DOM element is being\n   * removed from the DOM to animate it. Motion will be disabled if any of the provided\n   * flash messages does not contain an `id`.\n   */\n  const motionDisabled =\n    useReducedMotion(ref as any) || !isVisualRefresh || (items && !items.every(item => 'id' in item));\n\n  /**\n   * The `stackItems` property is a hidden boolean that allows for teams\n   * to beta test the flashbar stacking feature.\n   */\n  const stackItems = (restProps as any).stackItems;\n  const ariaLabels = (restProps as any).ariaLabels;\n  const isFlashbarStacked = stackItems && items?.length > 3;\n  const [isFlashbarStackExpanded, setIsFlashbarStackExpanded] = useState(false);\n\n  /**\n   * Compute the appropriate aria label for the stacked notifications toggle button\n   * based on the expanded/collapsed state of the stack and the presence of\n   * corresponding aria label properties.\n   */\n  function getStackButtonAriaLabel() {\n    let stackButtonAriaLabel;\n\n    if (isFlashbarStackExpanded) {\n      stackButtonAriaLabel = ariaLabels?.stackCollapseLabel ?? 'Collapse stacked notifications';\n    } else {\n      stackButtonAriaLabel = ariaLabels?.stackExpandLabel ?? 'Expand stacked notifications';\n    }\n\n    return stackButtonAriaLabel;\n  }\n\n  /**\n   * If the `isFlashbarStacked` is true (which is only possible if `stackItems` is true)\n   * then the first item should be rendered followed by two dummy items that visually indicate\n   * two, three, or more items exist in the stack.\n   */\n  function renderStackedItems() {\n    if (!isFlashbarStacked) {\n      return;\n    }\n\n    const stackDepth = Math.min(3, items.length);\n    const stackedItems = items.slice(0, stackDepth);\n\n    return (\n      <div className={styles.stack} style={{ [customCssProps.flashbarStackDepth]: stackDepth }}>\n        {!isFlashbarStackExpanded && (\n          <div className={clsx(styles.collapsed, isVisualRefresh && styles['visual-refresh'])}>\n            {stackedItems.map((item, index) => (\n              <div className={styles.item} style={{ [customCssProps.flashbarStackIndex]: index }} key={index}>\n                {index === 0 && renderItem(item, item.id ?? index)}\n                {index > 0 && <div className={clsx(styles.flash, styles[`flash-type-${item.type ?? 'info'}`])} />}\n              </div>\n            ))}\n          </div>\n        )}\n\n        {isFlashbarStackExpanded && (\n          <div className={styles.expanded}>{items.map((item, index) => renderItem(item, item.id ?? index))}</div>\n        )}\n\n        <button\n          aria-label={getStackButtonAriaLabel()}\n          className={clsx(styles.toggle, isVisualRefresh && styles['visual-refresh'])}\n          onClick={() => setIsFlashbarStackExpanded(!isFlashbarStackExpanded)}\n          {...isFocusVisible}\n        >\n          <InternalIcon\n            className={clsx(styles.icon, isFlashbarStackExpanded && styles.expanded)}\n            size=\"small\"\n            name=\"angle-down\"\n          />\n        </button>\n      </div>\n    );\n  }\n\n  /**\n   * If the flashbar is flat and motion is `enabled` then the adding and removing of items\n   * from the flashbar will render with visual transitions.\n   */\n  function renderFlatItemsWithTransitions() {\n    if (isFlashbarStacked || motionDisabled || !items) {\n      return;\n    }\n\n    return (\n      <TransitionGroup component={null}>\n        {items &&\n          items.map((item, index) => (\n            <Transition\n              transitionChangeDelay={{ entering: TIMEOUT_FOR_ENTERING_ANIMATION }}\n              key={item.id ?? index}\n              in={true}\n            >\n              {(state: string, transitionRootElement: React.Ref<HTMLDivElement> | undefined) =>\n                renderItem(item, item.id ?? index, transitionRootElement, state)\n              }\n            </Transition>\n          ))}\n      </TransitionGroup>\n    );\n  }\n\n  /**\n   * If the flashbar is flat and motion is `disabled` then the adding and removing of items\n   * from the flashbar will render without visual transitions.\n   */\n  function renderFlatItemsWithoutTransitions() {\n    if (isFlashbarStacked || !motionDisabled || !items) {\n      return;\n    }\n\n    return <>{items.map((item, index) => renderItem(item, item.id ?? index))}</>;\n  }\n\n  /**\n   * This is a shared render function for a single flashbar item to be used\n   * by the stacking, motion, and non-motion item group render functions.\n   */\n  function renderItem(\n    item: FlashbarProps.MessageDefinition,\n    key: string | number,\n    transitionRootElement?: React.Ref<HTMLDivElement> | undefined,\n    transitionState?: string | undefined\n  ) {\n    return (\n      <Flash\n        // eslint-disable-next-line react/forbid-component-props\n        className={clsx(getVisualContextClassname('flashbar'), isVisualRefresh ? styles['flash-refresh'] : '')}\n        key={key}\n        ref={transitionRootElement}\n        transitionState={transitionState}\n        {...item}\n      />\n    );\n  }\n\n  return (\n    <div\n      {...baseProps}\n      className={clsx(baseProps.className, styles.flashbar, styles[`breakpoint-${breakpoint}`])}\n      ref={mergedRef}\n    >\n      {renderStackedItems()}\n      {renderFlatItemsWithTransitions()}\n      {renderFlatItemsWithoutTransitions()}\n    </div>\n  );\n}\n\napplyDisplayName(Flashbar, 'Flashbar');\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}