{"ast":null,"code":"import { KeyCode } from '../../keycode';\nimport * as logger from '../../logging';\nimport { isCommand, isDigit } from './utils/keys';\nimport { backspaceHandler, keyHandler, enterHandler } from './keyboard-handler';\nvar onAutoComplete = function (value, onChange, maskFormat) {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n  var autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\nvar preventDefault = function (event, result) {\n  return result && event.preventDefault();\n};\nvar useMask = function (_a) {\n  var _b = _a.value,\n    value = _b === void 0 ? '' : _b,\n    onBlur = _a.onBlur,\n    onChange = _a.onChange,\n    onKeyDown = _a.onKeyDown,\n    format = _a.format,\n    inputRef = _a.inputRef,\n    _c = _a.autofix,\n    autofix = _c === void 0 ? false : _c,\n    _d = _a.disableAutocompleteOnBlur,\n    disableAutocompleteOnBlur = _d === void 0 ? false : _d,\n    setPosition = _a.setPosition;\n  if (!format.isValid(value)) {\n    logger.warnOnce('useMask', \"Invalid string \\\"\".concat(value, \"\\\" provided\"));\n  }\n  var onMaskChange = function (updatedValue) {\n    var autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n    onChange(autofixedUpdatedValue);\n  };\n  var initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  var maskedValue = format.getValidValue(initialValue);\n  return {\n    value: maskedValue,\n    onKeyDown: function (event) {\n      var _a, _b;\n      var selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      var selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      var result;\n      var _c = event.detail,\n        keyCode = _c.keyCode,\n        key = _c.key,\n        ctrlKey = _c.ctrlKey,\n        metaKey = _c.metaKey;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n      if (result) {\n        var value_1 = result.value,\n          position = result.position;\n        onMaskChange(value_1);\n        setPosition(position);\n      }\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: function (_a) {\n      var detail = _a.detail;\n      return onMaskChange(detail.value);\n    },\n    onBlur: function () {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n      onBlur && onBlur();\n    },\n    onPaste: function (event) {\n      var _a, _b;\n      var text = (event.clipboardData || window.clipboardData).getData('text');\n      var selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      var selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      var formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    }\n  };\n};\nexport default useMask;","map":{"version":3,"mappings":"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","names":["KeyCode","logger","isCommand","isDigit","backspaceHandler","keyHandler","enterHandler","onAutoComplete","value","onChange","maskFormat","autoCompletedValue","autoComplete","preventDefault","event","result","useMask","_a","_b","onBlur","onKeyDown","format","inputRef","_c","autofix","_d","disableAutocompleteOnBlur","setPosition","isValid","warnOnce","onMaskChange","updatedValue","autofixedUpdatedValue","correctMinMaxValues","initialValue","maskedValue","getValidValue","selectionStart","current","selectionEnd","detail","keyCode","key","ctrlKey","metaKey","isSeparator","backspace","enter","position","value_1","onPaste","text","clipboardData","window","getData","formattedText","formatPastedText"],"sources":["/Users/dcastro/node_modules/src/internal/components/masked-input/use-mask.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject } from 'react';\nimport { InputProps } from '../../../input/interfaces';\nimport { NonCancelableEventHandler, CancelableEventHandler } from '../../events';\nimport { KeyCode } from '../../keycode';\n\nimport * as logger from '../../logging';\nimport { isCommand, isDigit } from './utils/keys';\n\nimport MaskFormat from './utils/mask-format';\nimport { backspaceHandler, HandlerResult, keyHandler, enterHandler } from './keyboard-handler';\n\ninterface UseMaskHook {\n  value: string;\n  onChange: NonCancelableEventHandler<InputProps.ChangeDetail>;\n  onKeyDown: CancelableEventHandler<InputProps.KeyDetail>;\n  onBlur: NonCancelableEventHandler<null>;\n  onPaste: (event: ClipboardEvent) => void;\n}\n\ninterface UseMaskProps {\n  value: string;\n  onChange: (value: string) => void;\n  onKeyDown?: (event: CustomEvent) => void;\n  onBlur?: () => void;\n  format: MaskFormat;\n  autofix?: boolean;\n  inputRef: RefObject<HTMLInputElement>;\n  disableAutocompleteOnBlur?: boolean;\n  setPosition: (position: number | null) => void;\n}\n\nconst onAutoComplete = (value: string, onChange: UseMaskProps['onChange'], maskFormat: MaskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\n\nconst preventDefault = (event: CustomEvent, result?: HandlerResult | null) => result && event.preventDefault();\n\nconst useMask = ({\n  value = '',\n  onBlur,\n  onChange,\n  onKeyDown,\n  format,\n  inputRef,\n  autofix = false,\n  disableAutocompleteOnBlur = false,\n  setPosition,\n}: UseMaskProps): UseMaskHook => {\n  if (!format.isValid(value)) {\n    logger.warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n\n  const onMaskChange = (updatedValue: string) => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n\n    onChange(autofixedUpdatedValue);\n  };\n\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n\n  return {\n    value: maskedValue,\n    onKeyDown: (event: CustomEvent) => {\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      let result: HandlerResult | undefined;\n      const { keyCode, key, ctrlKey, metaKey } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n\n      if (result) {\n        const { value, position } = result;\n\n        onMaskChange(value);\n        setPosition(position);\n      }\n\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: ({ detail }) => onMaskChange(detail.value),\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n\n      onBlur && onBlur();\n    },\n    onPaste: (event: ClipboardEvent) => {\n      const text = (event.clipboardData || (window as any).clipboardData).getData('text');\n\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    },\n  };\n};\n\nexport default useMask;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}