{"ast":null,"code":"import { __assign } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nexport function useNavigation(_a) {\n  var series = _a.series,\n    visibleSeries = _a.visibleSeries,\n    scaledSeries = _a.scaledSeries,\n    barGroups = _a.barGroups,\n    xScale = _a.xScale,\n    yScale = _a.yScale,\n    highlightedPoint = _a.highlightedPoint,\n    highlightedGroupIndex = _a.highlightedGroupIndex,\n    highlightedSeries = _a.highlightedSeries,\n    legendSeries = _a.legendSeries,\n    isHandlersDisabled = _a.isHandlersDisabled,\n    pinPopover = _a.pinPopover,\n    highlightSeries = _a.highlightSeries,\n    highlightGroup = _a.highlightGroup,\n    highlightPoint = _a.highlightPoint;\n  var _b = useState(null),\n    targetX = _b[0],\n    setTargetX = _b[1];\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  var isGroupNavigation = visibleSeries.some(function (_a) {\n    var series = _a.series;\n    return series.type === 'bar';\n  });\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  var navigableSeries = useMemo(function () {\n    return findNavigableSeries(visibleSeries);\n  }, [visibleSeries]).navigableSeries;\n  var onBarGroupFocus = function () {\n    var groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;\n    setTargetX(xScale.domain[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n  var onLineGroupFocus = function () {\n    var _a, _b, _c;\n    if (!highlightedSeries || !highlightedPoint) {\n      var targetSeries = (_c = (_a = highlightedSeries !== null && highlightedSeries !== void 0 ? highlightedSeries : legendSeries) !== null && _a !== void 0 ? _a : (_b = series[0]) === null || _b === void 0 ? void 0 : _b.series) !== null && _c !== void 0 ? _c : null;\n      highlightSeries(targetSeries);\n      for (var _i = 0, scaledSeries_1 = scaledSeries; _i < scaledSeries_1.length; _i++) {\n        var scaledS = scaledSeries_1[_i];\n        if (scaledS.series === targetSeries) {\n          highlightPoint(scaledS);\n          return;\n        }\n      }\n    }\n  };\n  var onFocus = function () {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineGroupFocus();\n    }\n  };\n  var moveBetweenSeries = useCallback(function (direction) {\n    var _a, _b, _c, _d;\n    if (isGroupNavigation) {\n      return;\n    }\n    var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n    var MAX_SERIES_INDEX = navigableSeries.length - 1;\n    // Find the index of the currently highlighted series (if any)\n    var previousSeriesIndex = -1;\n    if (highlightedSeries) {\n      previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n    }\n    // Move forwards or backwards to the new series\n    var nextSeriesIndex = 0;\n    if (previousSeriesIndex !== -1) {\n      nextSeriesIndex = previousSeriesIndex + direction;\n      if (nextSeriesIndex > MAX_SERIES_INDEX) {\n        nextSeriesIndex = 0;\n      } else if (nextSeriesIndex < 0) {\n        nextSeriesIndex = MAX_SERIES_INDEX;\n      }\n    }\n    var nextSeries = navigableSeries[nextSeriesIndex];\n    var nextInternalSeries = series.filter(function (_a) {\n      var series = _a.series;\n      return series === nextSeries;\n    })[0];\n    // 2. Find point in the next series\n    var targetXPoint = ((_a = xScale.d3Scale(targetX)) !== null && _a !== void 0 ? _a : NaN) + xOffset;\n    if (!isFinite(targetXPoint)) {\n      targetXPoint = 0;\n    }\n    if (nextSeries.type === 'line') {\n      var nextScaledSeries = scaledSeries.filter(function (it) {\n        return it.series === nextSeries;\n      });\n      var closestNextSeriesPoint = nextScaledSeries.reduce(function (prev, curr) {\n        return Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev;\n      }, {\n        x: -Infinity,\n        y: -Infinity\n      });\n      highlightSeries(nextSeries);\n      highlightPoint(__assign(__assign({}, closestNextSeriesPoint), {\n        color: nextInternalSeries.color,\n        series: nextSeries\n      }));\n    } else if (isYThreshold(nextSeries)) {\n      var scaledTargetIndex = scaledSeries.map(function (it) {\n        var _a;\n        return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null;\n      }).indexOf(targetX);\n      highlightSeries(nextSeries);\n      highlightPoint({\n        x: targetXPoint,\n        y: (_b = yScale.d3Scale(nextSeries.y)) !== null && _b !== void 0 ? _b : NaN,\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: (_c = scaledSeries[scaledTargetIndex]) === null || _c === void 0 ? void 0 : _c.datum\n      });\n    } else if (isXThreshold(nextSeries)) {\n      highlightSeries(nextSeries);\n      highlightPoint({\n        x: (_d = xScale.d3Scale(nextSeries.x)) !== null && _d !== void 0 ? _d : NaN,\n        y: yScale.d3Scale.range()[0],\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: {\n          x: nextSeries.x,\n          y: NaN\n        }\n      });\n    }\n  }, [isGroupNavigation, xScale, navigableSeries, highlightedSeries, scaledSeries, series, targetX, highlightSeries, highlightPoint, yScale]);\n  var moveWithinSeries = useCallback(function (direction) {\n    var _a;\n    var series = highlightedSeries || visibleSeries[0].series;\n    var previousPoint = highlightedPoint || scaledSeries[0];\n    if (series.type === 'line' || isYThreshold(series)) {\n      var targetScaledSeries = scaledSeries.filter(function (it) {\n        return it.series === series;\n      });\n      var indexOfPreviousPoint = targetScaledSeries.map(function (it) {\n        return it.x;\n      }).indexOf(previousPoint.x);\n      var nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n      var nextPoint = targetScaledSeries[nextPointIndex];\n      setTargetX(((_a = nextPoint.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n      highlightSeries(series);\n      highlightPoint(nextPoint);\n    } else if (series.type === 'bar') {\n      var xDomain = xScale.domain;\n      var MAX_GROUP_INDEX = xDomain.length - 1;\n      var nextGroupIndex = 0;\n      if (highlightedGroupIndex !== null) {\n        // find next group\n        nextGroupIndex = highlightedGroupIndex + direction;\n        if (nextGroupIndex > MAX_GROUP_INDEX) {\n          nextGroupIndex = 0;\n        } else if (nextGroupIndex < 0) {\n          nextGroupIndex = MAX_GROUP_INDEX;\n        }\n      }\n      var nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n      setTargetX(xDomain[nextDomainIndex]);\n      highlightGroup(nextDomainIndex);\n    }\n  }, [highlightedSeries, visibleSeries, highlightedPoint, scaledSeries, highlightSeries, highlightPoint, xScale.domain, highlightedGroupIndex, barGroups, highlightGroup]);\n  var onKeyDown = useCallback(function (event) {\n    var keyCode = event.keyCode;\n    if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n      return;\n    }\n    event.preventDefault();\n    if (isHandlersDisabled) {\n      return;\n    }\n    if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n      moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n    } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n      moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n    } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n      pinPopover();\n    }\n  }, [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]);\n  return {\n    isGroupNavigation: isGroupNavigation,\n    onFocus: onFocus,\n    onKeyDown: onKeyDown\n  };\n}\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index, _a) {\n  var from = _a[0],\n    to = _a[1];\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useState","KeyCode","findNavigableSeries","isXThreshold","isYThreshold","nextValidDomainIndex","useNavigation","_a","series","visibleSeries","scaledSeries","barGroups","xScale","yScale","highlightedPoint","highlightedGroupIndex","highlightedSeries","legendSeries","isHandlersDisabled","pinPopover","highlightSeries","highlightGroup","highlightPoint","targetX","setTargetX","isGroupNavigation","some","type","onBarGroupFocus","groupIndex","domain","onLineGroupFocus","targetSeries","scaledSeries_1","_i","scaledS","onFocus","moveBetweenSeries","direction","xOffset","isCategorical","Math","max","d3Scale","bandwidth","MAX_SERIES_INDEX","navigableSeries","length","previousSeriesIndex","indexOf","nextSeriesIndex","nextSeries","nextInternalSeries","filter","targetXPoint","NaN","isFinite","nextScaledSeries","closestNextSeriesPoint","reduce","prev","curr","abs","x","Infinity","y","color","scaledTargetIndex","map","datum","range","moveWithinSeries","previousPoint","targetScaledSeries","indexOfPreviousPoint","nextPointIndex","circleIndex","nextPoint","xDomain","MAX_GROUP_INDEX","nextGroupIndex","nextDomainIndex","onKeyDown","event","keyCode","up","right","down","left","space","enter","preventDefault","index","from","to"],"sources":["/Users/dcastro/node_modules/src/mixed-line-bar-chart/hooks/use-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  legendSeries: null | MixedLineBarChartProps.ChartSeries<T>;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  clearHighlightedSeries(): void;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  legendSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = visibleSeries.some(({ series }) => series.type === 'bar');\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineGroupFocus = () => {\n    if (!highlightedSeries || !highlightedPoint) {\n      const targetSeries = highlightedSeries ?? legendSeries ?? series[0]?.series ?? null;\n      highlightSeries(targetSeries);\n      for (const scaledS of scaledSeries) {\n        if (scaledS.series === targetSeries) {\n          highlightPoint(scaledS);\n          return;\n        }\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineGroupFocus();\n    }\n  };\n\n  const moveBetweenSeries = useCallback(\n    (direction: number) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== -1) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = 0;\n        } else if (nextSeriesIndex < 0) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(targetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n        const closestNextSeriesPoint = nextScaledSeries.reduce(\n          (prev, curr) => (Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev),\n          { x: -Infinity, y: -Infinity }\n        );\n        highlightSeries(nextSeries);\n        highlightPoint({ ...closestNextSeriesPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (isYThreshold(nextSeries)) {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(targetX);\n        highlightSeries(nextSeries);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      } else if (isXThreshold(nextSeries)) {\n        highlightSeries(nextSeries);\n        highlightPoint({\n          x: xScale.d3Scale(nextSeries.x as any) ?? NaN,\n          y: yScale.d3Scale.range()[0],\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: { x: nextSeries.x, y: NaN },\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      scaledSeries,\n      series,\n      targetX,\n      highlightSeries,\n      highlightPoint,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n      const previousPoint = highlightedPoint || scaledSeries[0];\n\n      if (series.type === 'line' || isYThreshold(series)) {\n        const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n        const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n        const nextPoint = targetScaledSeries[nextPointIndex];\n\n        setTargetX(nextPoint.datum?.x || null);\n        highlightSeries(series);\n        highlightPoint(nextPoint);\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      highlightedPoint,\n      scaledSeries,\n      highlightSeries,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n    ]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown };\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}