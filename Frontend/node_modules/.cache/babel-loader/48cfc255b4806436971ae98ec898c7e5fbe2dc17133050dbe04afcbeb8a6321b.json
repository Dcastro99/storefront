{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { useSelector } from '../model/async-store';\nexport default function useHighlightDetails(_a) {\n  var model = _a.model,\n    xTickFormatter = _a.xTickFormatter,\n    yTickFormatter = _a.yTickFormatter,\n    detailTotalFormatter = _a.detailTotalFormatter,\n    detailTotalLabel = _a.detailTotalLabel;\n  var hX = useSelector(model.interactions, function (state) {\n    return state.highlightedX;\n  });\n  var hPoint = useSelector(model.interactions, function (state) {\n    return state.highlightedPoint;\n  });\n  var isPopoverPinned = useSelector(model.interactions, function (state) {\n    return state.isPopoverPinned;\n  });\n  if (!hX) {\n    return null;\n  }\n  var firstPoint = hX[0];\n  var highlightIndex = firstPoint.index.x;\n  var seriesPoints = __spreadArray([], model.computed.plot.xs[highlightIndex], true);\n  var detailsTotal = seriesPoints.reduce(function (total, point) {\n    return total + point.value;\n  }, 0);\n  var formattedX = xTickFormatter ? xTickFormatter(firstPoint.x) : firstPoint.x.toString();\n  var seriesTitle = hPoint ? getInternalSeries(hPoint).title : '';\n  var formattedY = hPoint ? getInternalSeries(hPoint).formatValue(hPoint.value, hPoint.x) : '';\n  var seriesDetails = seriesPoints.map(function (point) {\n    var _a = getInternalSeries(point),\n      title = _a.title,\n      formatValue = _a.formatValue,\n      color = _a.color,\n      markerType = _a.markerType;\n    var isDimmed = Boolean(hPoint) && point !== hPoint;\n    return {\n      key: title,\n      value: formatValue(point.value, point.x),\n      color: color,\n      markerType: markerType,\n      isDimmed: isDimmed\n    };\n  });\n  var totalDetails = [{\n    key: detailTotalLabel || '',\n    value: detailTotalFormatter ? detailTotalFormatter(detailsTotal) : yTickFormatter ? yTickFormatter(detailsTotal) : detailsTotal\n  }];\n  var pointDetails = hPoint ? seriesDetails[hPoint.index.s] : null;\n  var activeLabel = \"\".concat(seriesTitle, \" \").concat(formattedX, \" \").concat(formattedY, \", \").concat(totalDetails[0].key, \" \").concat(totalDetails[0].value);\n  return {\n    isPopoverPinned: isPopoverPinned,\n    highlightIndex: highlightIndex,\n    formattedX: formattedX,\n    seriesTitle: seriesTitle,\n    formattedY: formattedY,\n    activeLabel: activeLabel,\n    seriesDetails: seriesDetails,\n    totalDetails: totalDetails,\n    pointDetails: pointDetails\n  };\n  function getInternalSeries(point) {\n    return model.getInternalSeries(model.series[point.index.s]);\n  }\n}","map":{"version":3,"mappings":"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","names":["useSelector","useHighlightDetails","_a","model","xTickFormatter","yTickFormatter","detailTotalFormatter","detailTotalLabel","hX","interactions","highlightedX","hPoint","highlightedPoint","isPopoverPinned","highlightIndex","firstPoint","index","x","seriesPoints","computed","plot","xs","detailsTotal","reduce","total","point","value","formattedX","toString","seriesTitle","getInternalSeries","title","formattedY","formatValue","seriesDetails","map","color","markerType","isDimmed","Boolean","key","totalDetails","pointDetails","s","activeLabel","series"],"sources":["/Users/dcastro/node_modules/src/area-chart/elements/use-highlight-details.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { CartesianChartProps } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartSeriesDetailItem } from '../../internal/components/chart-series-details';\nimport { AreaChartProps } from '../interfaces';\nimport { ChartModel } from '../model';\nimport { useSelector } from '../model/async-store';\n\nexport interface HighlightDetails {\n  isPopoverPinned: boolean;\n  highlightIndex: number;\n  formattedX: string;\n  seriesTitle: string;\n  formattedY: number | string;\n  seriesDetails: readonly ChartSeriesDetailItem[];\n  totalDetails: readonly ChartSeriesDetailItem[];\n  pointDetails: null | ChartSeriesDetailItem;\n  activeLabel: string;\n}\n\nexport default function useHighlightDetails<T extends AreaChartProps.DataTypes>({\n  model,\n  xTickFormatter,\n  yTickFormatter,\n  detailTotalFormatter,\n  detailTotalLabel,\n}: {\n  model: ChartModel<T>;\n  xTickFormatter?: CartesianChartProps.TickFormatter<T>;\n  yTickFormatter?: CartesianChartProps.TickFormatter<number>;\n  detailTotalFormatter?: CartesianChartProps.TickFormatter<number>;\n  detailTotalLabel?: string;\n}): null | HighlightDetails {\n  const hX = useSelector(model.interactions, state => state.highlightedX);\n  const hPoint = useSelector(model.interactions, state => state.highlightedPoint);\n  const isPopoverPinned = useSelector(model.interactions, state => state.isPopoverPinned);\n\n  if (!hX) {\n    return null;\n  }\n\n  const [firstPoint] = hX;\n  const highlightIndex = firstPoint.index.x;\n  const seriesPoints = [...model.computed.plot.xs[highlightIndex]];\n  const detailsTotal = seriesPoints.reduce((total, point) => total + point.value, 0);\n  const formattedX = xTickFormatter ? xTickFormatter(firstPoint.x) : firstPoint.x.toString();\n  const seriesTitle = hPoint ? getInternalSeries(hPoint).title : '';\n  const formattedY = hPoint ? getInternalSeries(hPoint).formatValue(hPoint.value, hPoint.x) : '';\n  const seriesDetails = seriesPoints.map(point => {\n    const { title, formatValue, color, markerType } = getInternalSeries(point);\n    const isDimmed = Boolean(hPoint) && point !== hPoint;\n    return { key: title, value: formatValue(point.value, point.x), color, markerType, isDimmed };\n  });\n  const totalDetails = [\n    {\n      key: detailTotalLabel || '',\n      value: detailTotalFormatter\n        ? detailTotalFormatter(detailsTotal)\n        : yTickFormatter\n        ? yTickFormatter(detailsTotal)\n        : detailsTotal,\n    },\n  ];\n  const pointDetails = hPoint ? seriesDetails[hPoint.index.s] : null;\n  const activeLabel = `${seriesTitle} ${formattedX} ${formattedY}, ${totalDetails[0].key} ${totalDetails[0].value}`;\n\n  return {\n    isPopoverPinned,\n    highlightIndex,\n    formattedX,\n    seriesTitle,\n    formattedY,\n    activeLabel,\n    seriesDetails,\n    totalDetails,\n    pointDetails,\n  };\n\n  function getInternalSeries(point: ChartModel.PlotPoint<T>) {\n    return model.getInternalSeries(model.series[point.index.s]);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}