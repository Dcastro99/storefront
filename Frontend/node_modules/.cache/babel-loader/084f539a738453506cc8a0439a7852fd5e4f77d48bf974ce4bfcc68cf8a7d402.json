{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { useEffect, useState } from 'react';\nimport styles from './styles.css.js';\nimport { getOverflowParentDimensions } from '../internal/utils/scrollable-containers';\nimport { browserScrollbarSize } from '../internal/utils/browser-scrollbar-size';\nimport { supportsStickyPosition, getContainingBlock } from '../internal/utils/dom';\nvar updatePosition = function (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, hasContainingBlock, consideredFooterHeight) {\n  if (!tableEl || !scrollbarEl || !wrapperEl) {\n    return;\n  }\n  // parent is either some container or document itself\n  var parent = getOverflowParentDimensions(wrapperEl)[0];\n  var parentBottom = parent.top + parent.height;\n  // table bottom is visible when\n  // 1. table bottom reached end of the window\n  // 2. table bottom is not overlapped by footer\n  var _a = tableEl.getBoundingClientRect(),\n    tableTop = _a.top,\n    tableBottom = _a.bottom,\n    tableWidth = _a.width;\n  var wrapperWidth = wrapperEl.getBoundingClientRect().width;\n  //scrollbar correction is needed for\n  // #1 when scrollbars are constantly visible,\n  // we want no visible break when switching between fake and real scrollbars\n  // #2 when scrollbars are visible only on scrolling and half transparent (on mac)\n  // we want to avoid any overlap between fake and real scrollbar\n  // using 15 px as a height of transparent scrollbar on mac\n  var scrollbarHeight = browserScrollbarSize().height;\n  var scrollBarCorrection = scrollbarHeight > 0 ? scrollbarHeight : -15 / 2;\n  var tableBottomIsVisible = parentBottom - consideredFooterHeight >= tableBottom + scrollBarCorrection;\n  var tableTopIsHidden = tableTop >= parentBottom - consideredFooterHeight - scrollBarCorrection;\n  var areaIsScrollable = tableWidth > wrapperWidth;\n  if (tableBottomIsVisible || tableTopIsHidden || !areaIsScrollable) {\n    scrollbarEl.classList.remove(styles['sticky-scrollbar-visible']);\n  } else {\n    // when scrollbar is not displayed scrollLeft property cannot be set by useScrollSync\n    // that's why syncing it separately\n    if (!scrollbarEl.classList.contains(styles['sticky-scrollbar-visible'])) {\n      requestAnimationFrame(function () {\n        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;\n      });\n    }\n    scrollbarEl.classList.add(styles['sticky-scrollbar-visible']);\n  }\n  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {\n    scrollbarEl.style.height = \"\".concat(scrollbarHeight, \"px\");\n    scrollbarContentEl.style.height = \"\".concat(scrollbarHeight, \"px\");\n  }\n  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {\n    var parent_1 = getOverflowParentDimensions(wrapperEl)[0];\n    var wrapperElRect = wrapperEl.getBoundingClientRect();\n    var tableElRect = tableEl.getBoundingClientRect();\n    scrollbarEl.style.width = \"\".concat(wrapperElRect.width, \"px\");\n    scrollbarContentEl.style.width = \"\".concat(tableElRect.width, \"px\");\n    // when using sticky scrollbars in containers\n    // we agreed to ignore dynamic bottom calculations for footer overlap\n    scrollbarEl.style.left = hasContainingBlock ? '0px' : \"\".concat(wrapperElRect.left, \"px\");\n    scrollbarEl.style.top = hasContainingBlock ? '0px' : \"\".concat(Math.min(parent_1.top + parent_1.height, window.innerHeight - consideredFooterHeight), \"px\");\n  }\n};\nexport function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, footerHeight) {\n  // We don't take into account containing-block calculations because that would\n  // unnecessarily overcomplicate the position logic. For now, we assume that a\n  // containing block, if present, is below the app layout and above the overflow\n  // parent, which is a pretty safe assumption.\n  var _a = useState(false),\n    hasContainingBlock = _a[0],\n    setHasContainingBlock = _a[1];\n  var consideredFooterHeight = hasContainingBlock ? 0 : footerHeight;\n  useEffect(function () {\n    if (supportsStickyPosition()) {\n      var scrollHandler_1 = function () {\n        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);\n      };\n      scrollHandler_1();\n      window.addEventListener('scroll', scrollHandler_1, true);\n      return function () {\n        window.removeEventListener('scroll', scrollHandler_1, true);\n      };\n    }\n  }, [scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, scrollbarContentRef, hasContainingBlock]);\n  var wrapperEl = wrapperRef.current;\n  useEffect(function () {\n    if (wrapperEl && supportsStickyPosition()) {\n      setHasContainingBlock(!!getContainingBlock(wrapperEl));\n    }\n  }, [wrapperEl]);\n  useEffect(function () {\n    if (supportsStickyPosition() && tableRef.current) {\n      var observer_1 = new ResizeObserver(function (entries) {\n        if (scrollbarContentRef.current) {\n          scrollbarContentRef.current.style.width = \"\".concat(entries[0].borderBoxSize[0].inlineSize, \"px\");\n          updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);\n        }\n      });\n      observer_1.observe(tableRef.current);\n      return function () {\n        observer_1.disconnect();\n      };\n    }\n  }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, hasContainingBlock]);\n  useEffect(function () {\n    if (supportsStickyPosition()) {\n      var resizeHandler_1 = function () {\n        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);\n      };\n      window.addEventListener('resize', resizeHandler_1);\n      return function () {\n        window.removeEventListener('resize', resizeHandler_1);\n      };\n    }\n  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);\n}","map":{"version":3,"mappings":"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","names":["ResizeObserver","useEffect","useState","styles","getOverflowParentDimensions","browserScrollbarSize","supportsStickyPosition","getContainingBlock","updatePosition","tableEl","wrapperEl","scrollbarEl","scrollbarContentEl","hasContainingBlock","consideredFooterHeight","parent","parentBottom","top","height","getBoundingClientRect","tableTop","tableBottom","tableWidth","wrapperWidth","scrollbarHeight","scrollBarCorrection","tableBottomIsVisible","tableTopIsHidden","areaIsScrollable","classList","remove","contains","requestAnimationFrame","scrollLeft","add","style","parent_1","wrapperElRect","tableElRect","width","left","Math","min","window","innerHeight","useStickyScrollbar","scrollbarRef","scrollbarContentRef","tableRef","wrapperRef","footerHeight","setHasContainingBlock","scrollHandler_1","current","addEventListener","removeEventListener","observer_1","entries","borderBoxSize","inlineSize","observe","disconnect","resizeHandler_1"],"sources":["/Users/dcastro/node_modules/src/table/use-sticky-scrollbar.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport { RefObject, useEffect, useState } from 'react';\nimport styles from './styles.css.js';\n\nimport { getOverflowParentDimensions } from '../internal/utils/scrollable-containers';\nimport { browserScrollbarSize } from '../internal/utils/browser-scrollbar-size';\nimport { supportsStickyPosition, getContainingBlock } from '../internal/utils/dom';\n\nconst updatePosition = (\n  tableEl: HTMLElement | null,\n  wrapperEl: HTMLElement | null,\n  scrollbarEl: HTMLElement | null,\n  scrollbarContentEl: HTMLElement | null,\n  hasContainingBlock: boolean,\n  consideredFooterHeight: number\n) => {\n  if (!tableEl || !scrollbarEl || !wrapperEl) {\n    return;\n  }\n\n  // parent is either some container or document itself\n  const parent = getOverflowParentDimensions(wrapperEl)[0];\n  const parentBottom = parent.top + parent.height;\n\n  // table bottom is visible when\n  // 1. table bottom reached end of the window\n  // 2. table bottom is not overlapped by footer\n  const { top: tableTop, bottom: tableBottom, width: tableWidth } = tableEl.getBoundingClientRect();\n  const { width: wrapperWidth } = wrapperEl.getBoundingClientRect();\n\n  //scrollbar correction is needed for\n  // #1 when scrollbars are constantly visible,\n  // we want no visible break when switching between fake and real scrollbars\n  // #2 when scrollbars are visible only on scrolling and half transparent (on mac)\n  // we want to avoid any overlap between fake and real scrollbar\n  // using 15 px as a height of transparent scrollbar on mac\n  const scrollbarHeight = browserScrollbarSize().height;\n  const scrollBarCorrection = scrollbarHeight > 0 ? scrollbarHeight : -15 / 2;\n  const tableBottomIsVisible = parentBottom - consideredFooterHeight >= tableBottom + scrollBarCorrection;\n  const tableTopIsHidden = tableTop >= parentBottom - consideredFooterHeight - scrollBarCorrection;\n  const areaIsScrollable = tableWidth > wrapperWidth;\n\n  if (tableBottomIsVisible || tableTopIsHidden || !areaIsScrollable) {\n    scrollbarEl.classList.remove(styles['sticky-scrollbar-visible']);\n  } else {\n    // when scrollbar is not displayed scrollLeft property cannot be set by useScrollSync\n    // that's why syncing it separately\n    if (!scrollbarEl.classList.contains(styles['sticky-scrollbar-visible'])) {\n      requestAnimationFrame(() => {\n        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;\n      });\n    }\n\n    scrollbarEl.classList.add(styles['sticky-scrollbar-visible']);\n  }\n\n  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {\n    scrollbarEl.style.height = `${scrollbarHeight}px`;\n    scrollbarContentEl.style.height = `${scrollbarHeight}px`;\n  }\n\n  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {\n    const parent = getOverflowParentDimensions(wrapperEl)[0];\n\n    const wrapperElRect = wrapperEl.getBoundingClientRect();\n    const tableElRect = tableEl.getBoundingClientRect();\n    scrollbarEl.style.width = `${wrapperElRect.width}px`;\n    scrollbarContentEl.style.width = `${tableElRect.width}px`;\n\n    // when using sticky scrollbars in containers\n    // we agreed to ignore dynamic bottom calculations for footer overlap\n    scrollbarEl.style.left = hasContainingBlock ? '0px' : `${wrapperElRect.left}px`;\n    scrollbarEl.style.top = hasContainingBlock\n      ? '0px'\n      : `${Math.min(parent.top + parent.height, window.innerHeight - consideredFooterHeight)}px`;\n  }\n};\n\nexport function useStickyScrollbar(\n  scrollbarRef: RefObject<HTMLDivElement>,\n  scrollbarContentRef: RefObject<HTMLDivElement>,\n  tableRef: RefObject<HTMLTableElement>,\n  wrapperRef: RefObject<HTMLDivElement>,\n  footerHeight: number\n) {\n  // We don't take into account containing-block calculations because that would\n  // unnecessarily overcomplicate the position logic. For now, we assume that a\n  // containing block, if present, is below the app layout and above the overflow\n  // parent, which is a pretty safe assumption.\n  const [hasContainingBlock, setHasContainingBlock] = useState(false);\n  const consideredFooterHeight = hasContainingBlock ? 0 : footerHeight;\n\n  useEffect(() => {\n    if (supportsStickyPosition()) {\n      const scrollHandler = () => {\n        updatePosition(\n          tableRef.current,\n          wrapperRef.current,\n          scrollbarRef.current,\n          scrollbarContentRef.current,\n          hasContainingBlock,\n          consideredFooterHeight\n        );\n      };\n      scrollHandler();\n      window.addEventListener('scroll', scrollHandler, true);\n      return () => {\n        window.removeEventListener('scroll', scrollHandler, true);\n      };\n    }\n  }, [scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, scrollbarContentRef, hasContainingBlock]);\n\n  const wrapperEl = wrapperRef.current;\n  useEffect(() => {\n    if (wrapperEl && supportsStickyPosition()) {\n      setHasContainingBlock(!!getContainingBlock(wrapperEl));\n    }\n  }, [wrapperEl]);\n\n  useEffect(() => {\n    if (supportsStickyPosition() && tableRef.current) {\n      const observer = new ResizeObserver(entries => {\n        if (scrollbarContentRef.current) {\n          scrollbarContentRef.current.style.width = `${entries[0].borderBoxSize[0].inlineSize}px`;\n          updatePosition(\n            tableRef.current,\n            wrapperRef.current,\n            scrollbarRef.current,\n            scrollbarContentRef.current,\n            hasContainingBlock,\n            consideredFooterHeight\n          );\n        }\n      });\n      observer.observe(tableRef.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, hasContainingBlock]);\n\n  useEffect(() => {\n    if (supportsStickyPosition()) {\n      const resizeHandler = () => {\n        updatePosition(\n          tableRef.current,\n          wrapperRef.current,\n          scrollbarRef.current,\n          scrollbarContentRef.current,\n          hasContainingBlock,\n          consideredFooterHeight\n        );\n      };\n      window.addEventListener('resize', resizeHandler);\n      return () => {\n        window.removeEventListener('resize', resizeHandler);\n      };\n    }\n  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}