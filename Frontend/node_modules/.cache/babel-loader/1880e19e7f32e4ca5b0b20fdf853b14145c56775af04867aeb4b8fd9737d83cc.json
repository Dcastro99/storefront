{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __spreadArray } from \"tslib\";\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { matchFilteringProperty, matchOperator, matchOperatorPrefix, trimFirstSpace, trimStart } from './utils';\nexport var getQueryActions = function (query, onChange, inputRef) {\n  var tokens = query.tokens,\n    operation = query.operation;\n  var fireOnChange = function (tokens, operation) {\n    return fireNonCancelableEvent(onChange, {\n      tokens: tokens,\n      operation: operation\n    });\n  };\n  var setToken = function (index, newToken) {\n    var newTokens = __spreadArray([], tokens, true);\n    if (newTokens && index < newTokens.length) {\n      newTokens[index] = newToken;\n    }\n    fireOnChange(newTokens, operation);\n  };\n  var removeToken = function (index) {\n    var _a;\n    var newTokens = tokens.filter(function (_, i) {\n      return i !== index;\n    });\n    fireOnChange(newTokens, operation);\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus({\n      preventDropdown: true\n    });\n  };\n  var removeAllTokens = function () {\n    var _a;\n    fireOnChange([], operation);\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus({\n      preventDropdown: true\n    });\n  };\n  var addToken = function (newToken) {\n    var newTokens = __spreadArray([], tokens, true);\n    newTokens.push(newToken);\n    fireOnChange(newTokens, operation);\n  };\n  var setOperation = function (newOperation) {\n    fireOnChange(tokens, newOperation);\n  };\n  return {\n    setToken: setToken,\n    removeToken: removeToken,\n    removeAllTokens: removeAllTokens,\n    addToken: addToken,\n    setOperation: setOperation\n  };\n};\nexport var getAllowedOperators = function (property) {\n  var _a = property.operators,\n    operators = _a === void 0 ? [] : _a,\n    defaultOperator = property.defaultOperator;\n  var operatorOrder = ['=', '!=', ':', '!:', '>=', '<=', '<', '>'];\n  var operatorSet = new Set(__spreadArray([defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='], operators.map(function (op) {\n    return typeof op === 'string' ? op : op.operator;\n  }), true));\n  return operatorOrder.filter(function (op) {\n    return operatorSet.has(op);\n  });\n};\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\nexport var parseText = function (filteringText, filteringProperties, disableFreeTextFiltering) {\n  if (filteringProperties === void 0) {\n    filteringProperties = [];\n  }\n  var negatedGlobalQuery = /^(!:|!)(.*)/.exec(filteringText);\n  if (!disableFreeTextFiltering && negatedGlobalQuery) {\n    return {\n      step: 'free-text',\n      operator: '!:',\n      value: negatedGlobalQuery[2]\n    };\n  }\n  var property = matchFilteringProperty(filteringProperties, filteringText);\n  if (!property) {\n    return {\n      step: 'free-text',\n      value: filteringText\n    };\n  }\n  var allowedOps = getAllowedOperators(property);\n  var textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  var operator = matchOperator(allowedOps, trimStart(textWithoutProperty));\n  if (operator) {\n    var operatorLastIndex = textWithoutProperty.indexOf(operator) + operator.length;\n    var textWithoutPropertyAndOperator = textWithoutProperty.slice(operatorLastIndex);\n    return {\n      step: 'property',\n      property: property,\n      operator: operator,\n      // We need to remove the first leading space in case the user presses space\n      // after the operator, for example: Owner: admin, will result in value of ` admin`\n      // and we need to remove the first space, if the user added any more spaces only the\n      // first one will be removed.\n      value: trimFirstSpace(textWithoutPropertyAndOperator)\n    };\n  }\n  var operatorPrefix = matchOperatorPrefix(allowedOps, trimStart(textWithoutProperty));\n  if (operatorPrefix !== null) {\n    return {\n      step: 'operator',\n      property: property,\n      operatorPrefix: operatorPrefix\n    };\n  }\n  return {\n    step: 'free-text',\n    value: filteringText\n  };\n};\nexport var getPropertyOptions = function (filteringProperty, filteringOptions) {\n  return filteringOptions.filter(function (option) {\n    return option.propertyKey === filteringProperty.key;\n  });\n};\nexport var getAllValueSuggestions = function (filteringOptions, filteringProperties, operator, i18nStrings, customGroupsText) {\n  if (operator === void 0) {\n    operator = '=';\n  }\n  var defaultGroup = {\n    label: i18nStrings.groupValuesText,\n    options: []\n  };\n  var customGroups = {};\n  filteringOptions.forEach(function (filteringOption) {\n    var property = getPropertyByKey(filteringProperties, filteringOption.propertyKey);\n    // given option refers to a non-existent filtering property\n    if (!property) {\n      return;\n    }\n    // this option's filtering property does not support current operator\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n    if (property.group && !customGroups[property.group]) {\n      var label = customGroupsText.reduce(function (acc, customGroup) {\n        return customGroup.group === property.group ? customGroup.values : acc;\n      }, '');\n      customGroups[property.group] = {\n        label: label,\n        options: []\n      };\n    }\n    var propertyGroup = property.group ? customGroups[property.group] : defaultGroup;\n    propertyGroup.options.push({\n      tokenValue: property.propertyLabel + (operator || '=') + filteringOption.value,\n      label: filteringOption.value,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '=')\n    });\n  });\n  return __spreadArray([defaultGroup], Object.keys(customGroups).map(function (group) {\n    return customGroups[group];\n  }), true);\n};\nexport var getPropertyByKey = function (filteringProperties, key) {\n  var propertyMap = filteringProperties.reduce(function (acc, property) {\n    acc[property.key] = property;\n    return acc;\n  }, {});\n  return propertyMap[key];\n};\nexport function getExtendedOperator(filteringProperties, property, operator) {\n  var matchedProperty = getPropertyByKey(filteringProperties, property);\n  for (var _i = 0, _a = (matchedProperty === null || matchedProperty === void 0 ? void 0 : matchedProperty.operators) || []; _i < _a.length; _i++) {\n    var matchedOperator = _a[_i];\n    if (typeof matchedOperator === 'object' && matchedOperator.operator === operator) {\n      return matchedOperator;\n    }\n  }\n  return null;\n}\nexport function createPropertiesCompatibilityMap(filteringProperties) {\n  var lookup = {};\n  for (var _i = 0, filteringProperties_1 = filteringProperties; _i < filteringProperties_1.length; _i++) {\n    var property = filteringProperties_1[_i];\n    lookup[property.key] = (property.operators || []).map(function (operator) {\n      return typeof operator === 'object' ? {\n        operator: operator.operator,\n        form: operator.form\n      } : {\n        operator: operator,\n        form: undefined\n      };\n    }).sort(function (a, b) {\n      return a.operator.localeCompare(b.operator);\n    });\n  }\n  return function (propertyA, propertyB) {\n    if (lookup[propertyA].length !== lookup[propertyB].length) {\n      return false;\n    }\n    for (var i = 0; i < lookup[propertyA].length; i++) {\n      if (lookup[propertyA][i].operator !== lookup[propertyB][i].operator) {\n        return false;\n      }\n      if (lookup[propertyA][i].form !== lookup[propertyB][i].form) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nvar filteringPropertyToAutosuggestOption = function (filteringProperty) {\n  return {\n    value: filteringProperty.propertyLabel,\n    keepOpenOnSelect: true\n  };\n};\nexport function getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToOption) {\n  var defaultGroup = {\n    label: i18nStrings.groupPropertiesText,\n    options: []\n  };\n  var customGroups = {};\n  filteringProperties.forEach(function (filteringProperty) {\n    var group = filteringProperty.group;\n    var optionsGroup = defaultGroup;\n    if (group) {\n      if (!customGroups[group]) {\n        var label = customGroupsText.reduce(function (acc, customGroup) {\n          return customGroup.group === group ? customGroup.properties : acc;\n        }, '');\n        customGroups[group] = {\n          options: [],\n          label: label\n        };\n      }\n      optionsGroup = customGroups[group];\n    }\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  var defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  var customGroupsArray = Object.keys(customGroups).map(function (groupKey) {\n    return customGroups[groupKey];\n  });\n  return __spreadArray(__spreadArray([], defaultGroupArray, true), customGroupsArray, true);\n}\nexport var getAutosuggestOptions = function (parsedText, filteringOptions, filteringProperties, customGroupsText, i18nStrings) {\n  switch (parsedText.step) {\n    case 'property':\n      {\n        var _a = parsedText.property,\n          propertyLabel_1 = _a.propertyLabel,\n          groupValuesLabel = _a.groupValuesLabel;\n        var options = getPropertyOptions(parsedText.property, filteringOptions);\n        return {\n          filterText: parsedText.value,\n          options: [{\n            options: options.map(function (_a) {\n              var value = _a.value;\n              return {\n                tokenValue: propertyLabel_1 + parsedText.operator + value,\n                label: value,\n                __labelPrefix: propertyLabel_1 + ' ' + parsedText.operator\n              };\n            }),\n            label: groupValuesLabel\n          }]\n        };\n      }\n    case 'operator':\n      {\n        return {\n          filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n          options: __spreadArray(__spreadArray([], getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption), true), [{\n            options: getAllowedOperators(parsedText.property).map(function (value) {\n              return {\n                value: parsedText.property.propertyLabel + ' ' + value + ' ',\n                label: parsedText.property.propertyLabel + ' ' + value,\n                description: operatorToDescription(value, i18nStrings),\n                keepOpenOnSelect: true\n              };\n            }),\n            label: i18nStrings.operatorsText\n          }], false)\n        };\n      }\n    case 'free-text':\n      {\n        var needsValueSuggestions = !!parsedText.value;\n        var needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n        return {\n          filterText: parsedText.value,\n          options: __spreadArray(__spreadArray([], needsPropertySuggestions ? getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption) : [], true), needsValueSuggestions ? getAllValueSuggestions(filteringOptions, filteringProperties, parsedText.operator, i18nStrings, customGroupsText) : [], true)\n        };\n      }\n  }\n};\nexport var operatorToDescription = function (operator, i18nStrings) {\n  var _a;\n  var mapping = (_a = {}, _a['<'] = i18nStrings.operatorLessText, _a['<='] = i18nStrings.operatorLessOrEqualText, _a['>'] = i18nStrings.operatorGreaterText, _a['>='] = i18nStrings.operatorGreaterOrEqualText, _a[':'] = i18nStrings.operatorContainsText, _a['!:'] = i18nStrings.operatorDoesNotContainText, _a['='] = i18nStrings.operatorEqualsText, _a['!='] = i18nStrings.operatorDoesNotEqualText, _a);\n  return mapping[operator];\n};","map":{"version":3,"mappings":"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","names":["fireNonCancelableEvent","matchFilteringProperty","matchOperator","matchOperatorPrefix","trimFirstSpace","trimStart","getQueryActions","query","onChange","inputRef","operation","fireOnChange","tokens","setToken","index","newToken","newTokens","length","removeToken","filter","_","i","current","focus","preventDropdown","removeAllTokens","addToken","push","setOperation","newOperation","getAllowedOperators","property","operators","defaultOperator","operatorOrder","operatorSet","Set","map","op","operator","has","parseText","filteringText","filteringProperties","disableFreeTextFiltering","negatedGlobalQuery","exec","step","value","allowedOps","textWithoutProperty","substring","propertyLabel","operatorLastIndex","indexOf","textWithoutPropertyAndOperator","slice","operatorPrefix","getPropertyOptions","filteringProperty","filteringOptions","propertyKey","key","getAllValueSuggestions","i18nStrings","customGroupsText","defaultGroup","label","groupValuesText","options","customGroups","forEach","getPropertyByKey","filteringOption","group","reduce","acc","customGroup","values","propertyGroup","tokenValue","__labelPrefix","Object","keys","propertyMap","getExtendedOperator","matchedProperty","_a","_i","matchedOperator","createPropertiesCompatibilityMap","lookup","filteringProperties_1","form","undefined","sort","a","b","localeCompare","propertyA","propertyB","filteringPropertyToAutosuggestOption","keepOpenOnSelect","getPropertySuggestions","filteringPropertyToOption","groupPropertiesText","optionsGroup","properties","defaultGroupArray","customGroupsArray","groupKey","getAutosuggestOptions","parsedText","propertyLabel_1","groupValuesLabel","filterText","description","operatorToDescription","operatorsText","needsValueSuggestions","needsPropertySuggestions","mapping","operatorLessText","operatorLessOrEqualText","operatorGreaterText","operatorGreaterOrEqualText","operatorContainsText","operatorDoesNotContainText","operatorEqualsText","operatorDoesNotEqualText"],"sources":["/Users/dcastro/node_modules/src/property-filter/controller.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ComparisonOperator,\n  ExtendedOperatorForm,\n  FilteringOption,\n  FilteringProperty,\n  GroupText,\n  I18nStrings,\n  JoinOperation,\n  ParsedText,\n  Query,\n  Token,\n} from './interfaces';\nimport { fireNonCancelableEvent, NonCancelableEventHandler } from '../internal/events';\nimport { AutosuggestProps } from '../autosuggest/interfaces';\nimport { matchFilteringProperty, matchOperator, matchOperatorPrefix, trimFirstSpace, trimStart } from './utils';\nimport { AutosuggestInputRef } from '../internal/components/autosuggest-input';\n\nexport const getQueryActions = (\n  query: Query,\n  onChange: NonCancelableEventHandler<Query>,\n  inputRef: React.RefObject<AutosuggestInputRef>\n) => {\n  const { tokens, operation } = query;\n  const fireOnChange = (tokens: readonly Token[], operation: JoinOperation) =>\n    fireNonCancelableEvent(onChange, { tokens, operation });\n  const setToken = (index: number, newToken: Token) => {\n    const newTokens = [...tokens];\n    if (newTokens && index < newTokens.length) {\n      newTokens[index] = newToken;\n    }\n    fireOnChange(newTokens, operation);\n  };\n  const removeToken = (index: number) => {\n    const newTokens = tokens.filter((_, i) => i !== index);\n    fireOnChange(newTokens, operation);\n    inputRef.current?.focus({ preventDropdown: true });\n  };\n  const removeAllTokens = () => {\n    fireOnChange([], operation);\n    inputRef.current?.focus({ preventDropdown: true });\n  };\n  const addToken = (newToken: Token) => {\n    const newTokens = [...tokens];\n    newTokens.push(newToken);\n    fireOnChange(newTokens, operation);\n  };\n  const setOperation = (newOperation: JoinOperation) => {\n    fireOnChange(tokens, newOperation);\n  };\n  return {\n    setToken,\n    removeToken,\n    removeAllTokens,\n    addToken,\n    setOperation,\n  };\n};\n\nexport const getAllowedOperators = (property: FilteringProperty): ComparisonOperator[] => {\n  const { operators = [], defaultOperator } = property;\n  const operatorOrder = ['=', '!=', ':', '!:', '>=', '<=', '<', '>'] as const;\n  const operatorSet = new Set([\n    defaultOperator ?? '=',\n    ...operators.map(op => (typeof op === 'string' ? op : op.operator)),\n  ]);\n  return operatorOrder.filter(op => operatorSet.has(op));\n};\n\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\nexport const parseText = (\n  filteringText: string,\n  filteringProperties: readonly FilteringProperty[] = [],\n  disableFreeTextFiltering: boolean\n): ParsedText => {\n  const negatedGlobalQuery = /^(!:|!)(.*)/.exec(filteringText);\n  if (!disableFreeTextFiltering && negatedGlobalQuery) {\n    return {\n      step: 'free-text',\n      operator: '!:',\n      value: negatedGlobalQuery[2],\n    };\n  }\n\n  const property = matchFilteringProperty(filteringProperties, filteringText);\n  if (!property) {\n    return {\n      step: 'free-text',\n      value: filteringText,\n    };\n  }\n\n  const allowedOps = getAllowedOperators(property);\n  const textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  const operator = matchOperator(allowedOps, trimStart(textWithoutProperty));\n  if (operator) {\n    const operatorLastIndex = textWithoutProperty.indexOf(operator) + operator.length;\n    const textWithoutPropertyAndOperator = textWithoutProperty.slice(operatorLastIndex);\n    return {\n      step: 'property',\n      property,\n      operator,\n      // We need to remove the first leading space in case the user presses space\n      // after the operator, for example: Owner: admin, will result in value of ` admin`\n      // and we need to remove the first space, if the user added any more spaces only the\n      // first one will be removed.\n      value: trimFirstSpace(textWithoutPropertyAndOperator),\n    };\n  }\n\n  const operatorPrefix = matchOperatorPrefix(allowedOps, trimStart(textWithoutProperty));\n  if (operatorPrefix !== null) {\n    return { step: 'operator', property, operatorPrefix };\n  }\n\n  return {\n    step: 'free-text',\n    value: filteringText,\n  };\n};\n\nexport const getPropertyOptions = (\n  filteringProperty: FilteringProperty,\n  filteringOptions: readonly FilteringOption[]\n) => {\n  return filteringOptions.filter(option => option.propertyKey === filteringProperty.key);\n};\n\ninterface OptionGroup<T> {\n  label: string;\n  options: T[];\n}\n\ninterface ExtendedAutosuggestOption extends AutosuggestProps.Option {\n  tokenValue: string;\n}\n\nexport const getAllValueSuggestions = (\n  filteringOptions: readonly FilteringOption[],\n  filteringProperties: readonly FilteringProperty[],\n  operator: ComparisonOperator | undefined = '=',\n  i18nStrings: I18nStrings,\n  customGroupsText: readonly GroupText[]\n) => {\n  const defaultGroup: OptionGroup<ExtendedAutosuggestOption> = {\n    label: i18nStrings.groupValuesText,\n    options: [],\n  };\n  const customGroups: { [K in string]: OptionGroup<ExtendedAutosuggestOption> } = {};\n  filteringOptions.forEach(filteringOption => {\n    const property = getPropertyByKey(filteringProperties, filteringOption.propertyKey);\n    // given option refers to a non-existent filtering property\n    if (!property) {\n      return;\n    }\n    // this option's filtering property does not support current operator\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n    if (property.group && !customGroups[property.group]) {\n      const label = customGroupsText.reduce<string>(\n        (acc, customGroup) => (customGroup.group === property.group ? customGroup.values : acc),\n        ''\n      );\n      customGroups[property.group] = {\n        label,\n        options: [],\n      };\n    }\n    const propertyGroup = property.group ? customGroups[property.group] : defaultGroup;\n    propertyGroup.options.push({\n      tokenValue: property.propertyLabel + (operator || '=') + filteringOption.value,\n      label: filteringOption.value,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '='),\n    });\n  });\n  return [defaultGroup, ...Object.keys(customGroups).map(group => customGroups[group])];\n};\n\nexport const getPropertyByKey = (filteringProperties: readonly FilteringProperty[], key: string) => {\n  const propertyMap = filteringProperties.reduce<{ [K: string]: FilteringProperty }>((acc, property) => {\n    acc[property.key] = property;\n    return acc;\n  }, {});\n  return propertyMap[key] as FilteringProperty | undefined;\n};\n\nexport function getExtendedOperator(\n  filteringProperties: readonly FilteringProperty[],\n  property: string,\n  operator: ComparisonOperator\n) {\n  const matchedProperty = getPropertyByKey(filteringProperties, property);\n  for (const matchedOperator of matchedProperty?.operators || []) {\n    if (typeof matchedOperator === 'object' && matchedOperator.operator === operator) {\n      return matchedOperator;\n    }\n  }\n  return null;\n}\n\nexport function createPropertiesCompatibilityMap(\n  filteringProperties: readonly FilteringProperty[]\n): (propertyA: string, propertyB: string) => boolean {\n  const lookup: {\n    [propertyKey: string]: { operator: string; form: ExtendedOperatorForm<any> | undefined }[];\n  } = {};\n\n  for (const property of filteringProperties) {\n    lookup[property.key] = (property.operators || [])\n      .map(operator =>\n        typeof operator === 'object'\n          ? { operator: operator.operator, form: operator.form }\n          : { operator, form: undefined }\n      )\n      .sort((a, b) => a.operator.localeCompare(b.operator));\n  }\n\n  return (propertyA: string, propertyB: string) => {\n    if (lookup[propertyA].length !== lookup[propertyB].length) {\n      return false;\n    }\n    for (let i = 0; i < lookup[propertyA].length; i++) {\n      if (lookup[propertyA][i].operator !== lookup[propertyB][i].operator) {\n        return false;\n      }\n      if (lookup[propertyA][i].form !== lookup[propertyB][i].form) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\n\nconst filteringPropertyToAutosuggestOption = (filteringProperty: FilteringProperty) => ({\n  value: filteringProperty.propertyLabel,\n  keepOpenOnSelect: true,\n});\n\nexport function getPropertySuggestions<T>(\n  filteringProperties: readonly FilteringProperty[],\n  customGroupsText: readonly GroupText[],\n  i18nStrings: I18nStrings,\n  filteringPropertyToOption: (filteringProperty: FilteringProperty) => T\n) {\n  const defaultGroup: OptionGroup<T> = {\n    label: i18nStrings.groupPropertiesText,\n    options: [],\n  };\n  const customGroups: { [K in string]: OptionGroup<T> } = {};\n\n  filteringProperties.forEach(filteringProperty => {\n    const { group } = filteringProperty;\n    let optionsGroup = defaultGroup;\n    if (group) {\n      if (!customGroups[group]) {\n        const label = customGroupsText.reduce<string>(\n          (acc, customGroup) => (customGroup.group === group ? customGroup.properties : acc),\n          ''\n        );\n        customGroups[group] = { options: [], label };\n      }\n      optionsGroup = customGroups[group];\n    }\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  const defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  const customGroupsArray = Object.keys(customGroups).map(groupKey => customGroups[groupKey]);\n  return [...defaultGroupArray, ...customGroupsArray];\n}\n\nexport const getAutosuggestOptions = (\n  parsedText: ParsedText,\n  filteringOptions: readonly FilteringOption[],\n  filteringProperties: readonly FilteringProperty[],\n  customGroupsText: readonly GroupText[],\n  i18nStrings: I18nStrings\n) => {\n  switch (parsedText.step) {\n    case 'property': {\n      const { propertyLabel, groupValuesLabel } = parsedText.property;\n      const options = getPropertyOptions(parsedText.property, filteringOptions);\n      return {\n        filterText: parsedText.value,\n        options: [\n          {\n            options: options.map(({ value }) => ({\n              tokenValue: propertyLabel + parsedText.operator + value,\n              label: value,\n              __labelPrefix: propertyLabel + ' ' + parsedText.operator,\n            })),\n            label: groupValuesLabel,\n          },\n        ],\n      };\n    }\n    case 'operator': {\n      return {\n        filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n        options: [\n          ...getPropertySuggestions(\n            filteringProperties,\n            customGroupsText,\n            i18nStrings,\n            filteringPropertyToAutosuggestOption\n          ),\n          {\n            options: getAllowedOperators(parsedText.property).map(value => ({\n              value: parsedText.property.propertyLabel + ' ' + value + ' ',\n              label: parsedText.property.propertyLabel + ' ' + value,\n              description: operatorToDescription(value, i18nStrings),\n              keepOpenOnSelect: true,\n            })),\n            label: i18nStrings.operatorsText,\n          },\n        ],\n      };\n    }\n    case 'free-text': {\n      const needsValueSuggestions = !!parsedText.value;\n      const needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n      return {\n        filterText: parsedText.value,\n        options: [\n          ...(needsPropertySuggestions\n            ? getPropertySuggestions(\n                filteringProperties,\n                customGroupsText,\n                i18nStrings,\n                filteringPropertyToAutosuggestOption\n              )\n            : []),\n          ...(needsValueSuggestions\n            ? getAllValueSuggestions(\n                filteringOptions,\n                filteringProperties,\n                parsedText.operator,\n                i18nStrings,\n                customGroupsText\n              )\n            : []),\n        ],\n      };\n    }\n  }\n};\n\nexport const operatorToDescription = (operator: ComparisonOperator, i18nStrings: I18nStrings) => {\n  const mapping: { [K in ComparisonOperator]: string } = {\n    ['<']: i18nStrings.operatorLessText,\n    ['<=']: i18nStrings.operatorLessOrEqualText,\n    ['>']: i18nStrings.operatorGreaterText,\n    ['>=']: i18nStrings.operatorGreaterOrEqualText,\n    [':']: i18nStrings.operatorContainsText,\n    ['!:']: i18nStrings.operatorDoesNotContainText,\n    ['=']: i18nStrings.operatorEqualsText,\n    ['!=']: i18nStrings.operatorDoesNotEqualText,\n  };\n  return mapping[operator];\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}