{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\nexport var onPaginationClick = function (headerBarRef, direction) {\n  if (!(headerBarRef === null || headerBarRef === void 0 ? void 0 : headerBarRef.current)) {\n    return;\n  }\n  var element = headerBarRef.current;\n  // Scroll each paginated section by 75% of what is already visible\n  var paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n  if (direction === 1) {\n    smoothScroll(element, Math.min(element.scrollLeft + paginatedSectionSize, element.scrollWidth - element.offsetWidth));\n  }\n  if (direction === -1) {\n    smoothScroll(element, Math.max(element.scrollLeft - paginatedSectionSize, 0));\n  }\n};\nexport var hasHorizontalOverflow = function (headerBar, leftOverflowButton) {\n  var offsetWidth = headerBar.offsetWidth,\n    scrollWidth = headerBar.scrollWidth;\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  var paginationButtonsWidth = leftOverflowButton.current && 2 * leftOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\nexport var hasLeftOverflow = function (headerBar) {\n  return headerBar.scrollLeft > 0;\n};\nexport var hasRightOverflow = function (headerBar) {\n  var offsetWidth = headerBar.offsetWidth,\n    scrollLeft = headerBar.scrollLeft,\n    scrollWidth = headerBar.scrollWidth;\n  // scrollLeft can be a decimal value on systems using display scaling\n  return Math.ceil(scrollLeft) < scrollWidth - offsetWidth;\n};\nexport var scrollIntoView = function (tabHeader, headerBar, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  }\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  var margin = 2;\n  var updatedLeftScroll = headerBar.scrollLeft;\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(updatedLeftScroll, tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin);\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAOA,YAAY,MAAM,iBAAiB;AAE1C,OAAO,IAAMC,iBAAiB,GAAG,UAACC,YAA+C,EAAEC,SAAiB;EAClG,IAAI,EAACD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEE,OAAO,GAAE;IAC1B;;EAEF,IAAMC,OAAO,GAAGH,YAAY,CAACE,OAAO;EAEpC;EACA,IAAME,oBAAoB,GAAGC,IAAI,CAACC,IAAI,CAACH,OAAO,CAACI,WAAW,GAAG,IAAI,CAAC;EAElE,IAAIN,SAAS,KAAK,CAAC,EAAE;IACnBH,YAAY,CACVK,OAAO,EACPE,IAAI,CAACG,GAAG,CAACL,OAAO,CAACM,UAAU,GAAGL,oBAAoB,EAAED,OAAO,CAACO,WAAW,GAAGP,OAAO,CAACQ,WAAW,CAAC,CAC/F;;EAEH,IAAIV,SAAS,KAAK,CAAC,CAAC,EAAE;IACpBH,YAAY,CAACK,OAAO,EAAEE,IAAI,CAACO,GAAG,CAACT,OAAO,CAACM,UAAU,GAAGL,oBAAoB,EAAE,CAAC,CAAC,CAAC;;AAEjF,CAAC;AAED,OAAO,IAAMS,qBAAqB,GAAG,UACnCC,SAAsB,EACtBC,kBAAgD;EAExC,eAAW,GAAkBD,SAAS,YAA3B;IAAEJ,WAAW,GAAKI,SAAS,YAAd;EAEhC;EACA,IAAME,sBAAsB,GAAGD,kBAAkB,CAACb,OAAO,IAAI,CAAC,GAAGa,kBAAkB,CAACb,OAAO,CAACS,WAAW;EACvG,OAAOK,sBAAsB,GAAGN,WAAW,GAAGC,WAAW,GAAGK,sBAAsB,GAAGN,WAAW,GAAGC,WAAW;AAChH,CAAC;AAED,OAAO,IAAMM,eAAe,GAAG,UAACH,SAAsB;EACpD,OAAOA,SAAS,CAACL,UAAU,GAAG,CAAC;AACjC,CAAC;AAED,OAAO,IAAMS,gBAAgB,GAAG,UAACJ,SAAsB;EAC7C,eAAW,GAA8BA,SAAS,YAAvC;IAAEL,UAAU,GAAkBK,SAAS,WAA3B;IAAEJ,WAAW,GAAKI,SAAS,YAAd;EAC5C;EACA,OAAOT,IAAI,CAACC,IAAI,CAACG,UAAU,CAAC,GAAGC,WAAW,GAAGC,WAAW;AAC1D,CAAC;AAED,OAAO,IAAMQ,cAAc,GAAG,UAACC,SAAsB,EAAEN,SAAsB,EAAEO,MAAa;EAAb;IAAAA,aAAa;EAAA;EAC1F,IAAI,CAACD,SAAS,IAAI,CAACN,SAAS,EAAE;IAC5B;;EAEF;EACA,IAAMQ,MAAM,GAAG,CAAC;EAChB,IAAIC,iBAAiB,GAAGT,SAAS,CAACL,UAAU;EAE5C;EACAc,iBAAiB,GAAGlB,IAAI,CAACG,GAAG,CAACe,iBAAiB,EAAEH,SAAS,CAACI,UAAU,GAAGF,MAAM,CAAC;EAC9E;EACAC,iBAAiB,GAAGlB,IAAI,CAACO,GAAG,CAC1BW,iBAAiB,EACjBH,SAAS,CAACI,UAAU,GAAGJ,SAAS,CAACT,WAAW,GAAGG,SAAS,CAACH,WAAW,GAAGW,MAAM,CAC9E;EACD,IAAID,MAAM,EAAE;IACVvB,YAAY,CAACgB,SAAS,EAAES,iBAAiB,CAAC;GAC3C,MAAM;IACLT,SAAS,CAACL,UAAU,GAAGc,iBAAiB;;AAE5C,CAAC","names":["smoothScroll","onPaginationClick","headerBarRef","direction","current","element","paginatedSectionSize","Math","ceil","clientWidth","min","scrollLeft","scrollWidth","offsetWidth","max","hasHorizontalOverflow","headerBar","leftOverflowButton","paginationButtonsWidth","hasLeftOverflow","hasRightOverflow","scrollIntoView","tabHeader","smooth","margin","updatedLeftScroll","offsetLeft"],"sources":["/Users/dcastro/node_modules/src/tabs/scroll-utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\n\nexport const onPaginationClick = (headerBarRef: React.RefObject<HTMLUListElement>, direction: number): void => {\n  if (!headerBarRef?.current) {\n    return;\n  }\n  const element = headerBarRef.current;\n\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n\n  if (direction === 1) {\n    smoothScroll(\n      element,\n      Math.min(element.scrollLeft + paginatedSectionSize, element.scrollWidth - element.offsetWidth)\n    );\n  }\n  if (direction === -1) {\n    smoothScroll(element, Math.max(element.scrollLeft - paginatedSectionSize, 0));\n  }\n};\n\nexport const hasHorizontalOverflow = (\n  headerBar: HTMLElement,\n  leftOverflowButton: React.RefObject<HTMLElement>\n): boolean => {\n  const { offsetWidth, scrollWidth } = headerBar;\n\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = leftOverflowButton.current && 2 * leftOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\n\nexport const hasLeftOverflow = (headerBar: HTMLElement): boolean => {\n  return headerBar.scrollLeft > 0;\n};\n\nexport const hasRightOverflow = (headerBar: HTMLElement): boolean => {\n  const { offsetWidth, scrollLeft, scrollWidth } = headerBar;\n  // scrollLeft can be a decimal value on systems using display scaling\n  return Math.ceil(scrollLeft) < scrollWidth - offsetWidth;\n};\n\nexport const scrollIntoView = (tabHeader: HTMLElement, headerBar: HTMLElement, smooth = true): void => {\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(\n    updatedLeftScroll,\n    tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin\n  );\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}