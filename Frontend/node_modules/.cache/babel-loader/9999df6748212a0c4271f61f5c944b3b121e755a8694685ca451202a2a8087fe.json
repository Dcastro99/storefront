{"ast":null,"code":"import { __assign } from \"tslib\";\nexport var chartLegendMap = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed'\n};\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport var nextValidDomainIndex = function (nextGroupIndex, barGroups, direction) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n  var index = nextGroupIndex;\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries(series) {\n  var navigableSeries = [];\n  var navigableBarSeriesIndex = -1;\n  series.forEach(function (internalSeries) {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return {\n    navigableSeries: navigableSeries,\n    navigableBarSeriesIndex: navigableBarSeriesIndex\n  };\n}\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport var matchesX = function (x1, x2) {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n/**\n * Calculates list of offset maps from all data by accumulating each value\n */\nexport function calculateOffsetMaps(data) {\n  return data.reduce(function (acc, curr, idx) {\n    // First series receives empty offsets map\n    if (idx === 0) {\n      acc.push({\n        positiveOffsets: {},\n        negativeOffsets: {}\n      });\n    }\n    var lastMap = acc[idx];\n    var map = lastMap ? {\n      positiveOffsets: __assign({}, lastMap.positiveOffsets),\n      negativeOffsets: __assign({}, lastMap.negativeOffsets)\n    } : {\n      positiveOffsets: {},\n      negativeOffsets: {}\n    };\n    curr.forEach(function (_a) {\n      var x = _a.x,\n        y = _a.y;\n      var key = getKeyValue(x);\n      if (y < 0) {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.negativeOffsets[key]) || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.positiveOffsets[key]) || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    });\n    // Ignore last value for map but still run it for logging\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n    return acc;\n  }, []);\n}\n/** Returns string or number value for ChartDataTypes key */\nexport var getKeyValue = function (key) {\n  return key instanceof Date ? key.getTime() : key;\n};\nexport function isYThreshold(series) {\n  return series.type === 'threshold' && 'y' in series;\n}\nexport function isXThreshold(series) {\n  return series.type === 'threshold' && 'x' in series;\n}\nexport function isDataSeries(series) {\n  return series.type === 'line' || series.type === 'bar';\n}","map":{"version":3,"mappings":"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","names":["chartLegendMap","line","bar","threshold","nextValidDomainIndex","nextGroupIndex","barGroups","direction","index","length","isValid","hasData","findNavigableSeries","series","navigableSeries","navigableBarSeriesIndex","forEach","internalSeries","type","push","matchesX","x1","x2","Date","getTime","calculateOffsetMaps","data","reduce","acc","curr","idx","positiveOffsets","negativeOffsets","lastMap","map","_a","x","y","key","getKeyValue","lastValue","isYThreshold","isXThreshold","isDataSeries"],"sources":["/Users/dcastro/node_modules/src/mixed-line-bar-chart/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartSeriesMarkerType } from '../internal/components/chart-series-marker';\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ScaledBarGroup } from './make-scaled-bar-groups';\n\nexport const chartLegendMap: Record<string, ChartSeriesMarkerType> = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed',\n};\n\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport const nextValidDomainIndex = <T>(nextGroupIndex: number, barGroups: ScaledBarGroup<T>[], direction = 1) => {\n  let index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries<T extends ChartDataTypes>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const navigableSeries: Array<MixedLineBarChartProps.ChartSeries<T>> = [];\n  let navigableBarSeriesIndex = -1;\n\n  series.forEach(internalSeries => {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return { navigableSeries, navigableBarSeriesIndex };\n}\n\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport const matchesX = <T>(x1: T, x2: T) => {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n\nexport type OffsetMap = Record<string | number, number>;\n\nexport interface StackedOffsets {\n  positiveOffsets: OffsetMap;\n  negativeOffsets: OffsetMap;\n}\n\n/**\n * Calculates list of offset maps from all data by accumulating each value\n */\nexport function calculateOffsetMaps(\n  data: Array<readonly MixedLineBarChartProps.Datum<ChartDataTypes>[]>\n): StackedOffsets[] {\n  return data.reduce((acc, curr, idx) => {\n    // First series receives empty offsets map\n    if (idx === 0) {\n      acc.push({ positiveOffsets: {}, negativeOffsets: {} });\n    }\n    const lastMap = acc[idx];\n    const map: StackedOffsets = lastMap\n      ? { positiveOffsets: { ...lastMap.positiveOffsets }, negativeOffsets: { ...lastMap.negativeOffsets } }\n      : { positiveOffsets: {}, negativeOffsets: {} };\n\n    curr.forEach(({ x, y }) => {\n      const key = getKeyValue(x);\n      if (y < 0) {\n        const lastValue = lastMap?.negativeOffsets[key] || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        const lastValue = lastMap?.positiveOffsets[key] || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    });\n\n    // Ignore last value for map but still run it for logging\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n\n    return acc;\n  }, [] as StackedOffsets[]);\n}\n\n/** Returns string or number value for ChartDataTypes key */\nexport const getKeyValue = (key: ChartDataTypes) => (key instanceof Date ? key.getTime() : key);\n\nexport function isYThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.YThresholdSeries {\n  return series.type === 'threshold' && 'y' in series;\n}\n\nexport function isXThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.XThresholdSeries<T> {\n  return series.type === 'threshold' && 'x' in series;\n}\n\nexport function isDataSeries<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.DataSeries<T> {\n  return series.type === 'line' || series.type === 'bar';\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}