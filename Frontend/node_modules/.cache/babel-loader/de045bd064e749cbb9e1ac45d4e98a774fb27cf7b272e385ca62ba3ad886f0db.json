{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { padLeftZeros } from '../../../utils/strings';\nimport { insertAt } from './strings';\nvar MaskFormat = /** @class */function () {\n  function MaskFormat(_a) {\n    var separator = _a.separator,\n      _b = _a.inputSeparators,\n      inputSeparators = _b === void 0 ? [] : _b,\n      segments = _a.segments;\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n    this.inputSeparators = __spreadArray(__spreadArray([], inputSeparators, true), [separator], false);\n    this.enrichSegmentDefinitions(segments);\n  }\n  MaskFormat.prototype.tryAppendSeparator = function (value) {\n    var withSeparator = \"\".concat(value).concat(this.separator);\n    return this.isValid(withSeparator) ? withSeparator : value;\n  };\n  MaskFormat.prototype.isSeparator = function (key) {\n    return this.inputSeparators.indexOf(key) !== -1;\n  };\n  MaskFormat.prototype.isValid = function (value) {\n    var _this = this;\n    var inputSegments = value.split(this.separator);\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n    return inputSegments.every(function (segmentValue, i) {\n      var segment = _this.segments[i];\n      // disallow empty segments\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      // only allow numerals\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      }\n      // disallow incomplete segments, except at end\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      }\n      // limit numerical value\n      var intValue = parseInt(segmentValue, 10);\n      // Handles values padded with 0s that are lost during parsing\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n  };\n  MaskFormat.prototype.getValidValue = function (value) {\n    var validValue = value;\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n    return '';\n  };\n  MaskFormat.prototype.autoComplete = function (value) {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    var _a = value.split(this.separator).reverse(),\n      lastSegmentValue = _a[0],\n      completeSegmentValues = _a.slice(1);\n    var lastSegment = this.segments[completeSegmentValues.length];\n    // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n    var paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n    // recombine, and pad with extra segments for the full format\n    var partial = __spreadArray(__spreadArray([], completeSegmentValues.reverse(), true), [paddedLastSegmentValue], false);\n    while (partial.length < this.segments.length) {\n      var nextSegment = this.segments[partial.length];\n      var segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  };\n  MaskFormat.prototype.getSegmentValueWithAddition = function (position, value, enteredDigit) {\n    var segment = this.positionFormats[position];\n    var segmentValue = value.substr(segment.start, segment.length);\n    var segmentPosition = position - segment.start;\n    var newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  };\n  MaskFormat.prototype.replaceDigitsWithZeroes = function (value, cursorStart, cursorEnd) {\n    var position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n    // move selection forwards if it starts with a separator\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    }\n    // first, insert zeros in a partial segment at beginning of selection\n    if (!this.isSegmentStart(cursorStart)) {\n      var segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    }\n    // then loop through remaining segments, filling with zeros\n    var currentSegment;\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      var insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(value, padLeftZeros('', insertionEnd - currentSegment.start), currentSegment.start, insertionEnd);\n      cursorStart = insertionEnd + 1;\n    }\n    value = this.correctMinMaxValues(value);\n    return {\n      value: value,\n      position: position\n    };\n  };\n  MaskFormat.prototype.handleSeparatorInput = function (value, position) {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      var segment = this.positionFormats[position];\n      var segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value: value,\n        position: value.length\n      };\n    }\n  };\n  MaskFormat.prototype.isCursorAtSeparator = function (position) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  };\n  MaskFormat.prototype.isSegmentStart = function (position) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  };\n  MaskFormat.prototype.getSegmentMaxValue = function (value, position) {\n    return this.positionFormats[position].max(value);\n  };\n  MaskFormat.prototype.getSegmentMinValue = function (value, position) {\n    return this.positionFormats[position].min;\n  };\n  MaskFormat.prototype.getMaxLength = function () {\n    var last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  };\n  MaskFormat.prototype.deleteSeparator = function (value, position) {\n    value = insertAt(value, '0', position - 2, position - 1);\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2\n    };\n  };\n  MaskFormat.prototype.deleteDigit = function (value, position) {\n    value = insertAt(value, '0', position - 1, position);\n    // 23:59|: => backspace => 23:5|\n    var length = value.length;\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1\n    };\n  };\n  MaskFormat.prototype.correctMinMaxValues = function (value) {\n    var segment = this.positionFormats[0];\n    while (segment && value.length >= segment.end) {\n      var segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      var segmentMax = segment.max(value);\n      if (segmentValue < segment.min) {\n        var toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n      segment = this.positionFormats[segment.end + 1];\n    }\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  };\n  MaskFormat.prototype.formatPastedText = function (text, value, cursorStart, cursorEnd) {\n    var keyArr = text.trim().split('');\n    var position = cursorStart;\n    var formattedValue = value;\n    // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n    for (var _i = 0, keyArr_1 = keyArr; _i < keyArr_1.length; _i++) {\n      var key = keyArr_1[_i];\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n      var result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n    return this.tryAppendSeparator(formattedValue);\n  };\n  MaskFormat.prototype.processKey = function (initialValue, key, initialPosition) {\n    var value = initialValue;\n    var position = initialPosition;\n    if (this.isSeparator(key)) {\n      var result = this.handleSeparatorInput(value, position);\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      var isCursorAtEnd = position === value.length;\n      var segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      var segmentMaxValue = this.getSegmentMaxValue(value, position);\n      var segmentMinValue = this.getSegmentMinValue(value, position);\n      var firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      var isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      var exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, \"0\".concat(key), position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n    value = this.tryAppendSeparator(value);\n    // Move cursor in front of separator if behind after overwriting a character\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n    return {\n      value: value,\n      position: position\n    };\n  };\n  MaskFormat.prototype.padWithDefaultValue = function (segmentValue, segment) {\n    var defaultValue = (segment[\"default\"] || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  };\n  MaskFormat.prototype.enrichSegmentDefinitions = function (segments) {\n    this.positionFormats = {};\n    this.segments = [];\n    var position = 0;\n    var _loop_1 = function (segment) {\n      var max = segment.max;\n      var fullSegment = __assign(__assign({}, segment), {\n        max: typeof max === 'number' ? function () {\n          return max;\n        } : max,\n        start: position,\n        end: position + segment.length\n      });\n      this_1.segments.push(fullSegment);\n      // insert this format segment for every char in the max value\n      for (var j = 0; j < fullSegment.length; j++) {\n        this_1.positionFormats[position++] = fullSegment;\n      }\n      // skip a position for separator\n      position++;\n    };\n    var this_1 = this;\n    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n      var segment = segments_1[_i];\n      _loop_1(segment);\n    }\n  };\n  return MaskFormat;\n}();\nexport default MaskFormat;","map":{"version":3,"mappings":"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","names":["padLeftZeros","insertAt","_a","separator","_b","inputSeparators","segments","positionFormats","enrichSegmentDefinitions","MaskFormat","value","withSeparator","isValid","key","indexOf","inputSegments","split","length","every","segmentValue","i","segment","_this","match","intValue","parseInt","min","max","validValue","tryAppendSeparator","substring","reverse","lastSegmentValue","completeSegmentValues","lastSegment","paddedLastSegmentValue","padWithDefaultValue","partial","nextSegment","push","join","correctMinMaxValues","position","enteredDigit","substr","start","segmentPosition","newValue","cursorStart","cursorEnd","isCursorAtSeparator","isSegmentStart","end","currentSegment","insertionEnd","Math","getMaxLength","undefined","last","slice","segmentMax","toInsert","toFixed","text","keyArr","trim","formattedValue","keyArr_1","_i","result","processKey","initialValue","initialPosition","isSeparator","handleSeparatorInput","isCursorAtEnd","getSegmentValueWithAddition","segmentMaxValue","getSegmentMaxValue","segmentMinValue","getSegmentMinValue","firstDigitGreater","isValidPosition","exceedsMaxAtSegmentStart","defaultValue","fullSegment","this_1","j","segments_1"],"sources":["/Users/dcastro/node_modules/src/internal/components/masked-input/utils/mask-format.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { padLeftZeros } from '../../../utils/strings';\nimport { insertAt } from './strings';\n\ninterface FormatSegment {\n  min: number;\n  max: number | ((value: string) => number);\n  length: number;\n  default?: number;\n}\n\ninterface FormatSegmentFull extends FormatSegment {\n  start: number;\n  max(value: string): number;\n  end: number;\n}\n\nexport interface MaskArgs {\n  separator: string;\n  inputSeparators?: Array<string>;\n  segments: Array<FormatSegment>;\n}\n\nexport interface ChangeResult {\n  value: string;\n  position: number;\n}\n\nclass MaskFormat {\n  separator: string;\n  private inputSeparators: Array<string>;\n  private segments: Array<FormatSegmentFull>;\n  private positionFormats: { [x: number]: FormatSegmentFull };\n\n  constructor({ separator, inputSeparators = [], segments }: MaskArgs) {\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n\n    this.inputSeparators = [...inputSeparators, separator];\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  tryAppendSeparator(value: string) {\n    const withSeparator = `${value}${this.separator}`;\n    return this.isValid(withSeparator) ? withSeparator : value;\n  }\n\n  isSeparator(key: string): boolean {\n    return this.inputSeparators.indexOf(key) !== -1;\n  }\n\n  isValid(value: string): boolean {\n    const inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every((segmentValue, i) => {\n      const segment = this.segments[i];\n\n      // disallow empty segments\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      // only allow numerals\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      }\n      // disallow incomplete segments, except at end\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      }\n      // limit numerical value\n      const intValue = parseInt(segmentValue, 10);\n\n      // Handles values padded with 0s that are lost during parsing\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n  }\n\n  getValidValue(value: string): string {\n    let validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  }\n\n  autoComplete(value: string): string {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    const [lastSegmentValue, ...completeSegmentValues] = value.split(this.separator).reverse();\n    const lastSegment = this.segments[completeSegmentValues.length];\n\n    // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n    const paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n\n    // recombine, and pad with extra segments for the full format\n    const partial = [...completeSegmentValues.reverse(), paddedLastSegmentValue];\n    while (partial.length < this.segments.length) {\n      const nextSegment = this.segments[partial.length];\n      const segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  }\n\n  getSegmentValueWithAddition(position: number, value: string, enteredDigit: string) {\n    const segment = this.positionFormats[position];\n    const segmentValue = value.substr(segment.start, segment.length);\n    const segmentPosition = position - segment.start;\n    const newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  }\n\n  replaceDigitsWithZeroes(value: string, cursorStart: number, cursorEnd: number): ChangeResult {\n    const position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n\n    // move selection forwards if it starts with a separator\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    }\n\n    // first, insert zeros in a partial segment at beginning of selection\n    if (!this.isSegmentStart(cursorStart)) {\n      const segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    }\n\n    // then loop through remaining segments, filling with zeros\n    let currentSegment: FormatSegmentFull;\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      const insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(\n        value,\n        padLeftZeros('', insertionEnd - currentSegment.start),\n        currentSegment.start,\n        insertionEnd\n      );\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n\n    return {\n      value,\n      position,\n    };\n  }\n\n  handleSeparatorInput(value: string, position: number): ChangeResult | void {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      const segment = this.positionFormats[position];\n      let segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value,\n        position: value.length,\n      };\n    }\n  }\n\n  isCursorAtSeparator(position: number) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  }\n\n  isSegmentStart(position: number) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  }\n\n  getSegmentMaxValue(value: string, position: number): number {\n    return this.positionFormats[position].max(value);\n  }\n\n  getSegmentMinValue(value: string, position: number): number {\n    return this.positionFormats[position].min;\n  }\n\n  getMaxLength() {\n    const last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  }\n\n  deleteSeparator(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 2, position - 1);\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2,\n    };\n  }\n\n  deleteDigit(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 1, position);\n\n    // 23:59|: => backspace => 23:5|\n    const length = value.length;\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1,\n    };\n  }\n\n  correctMinMaxValues(value: string): string {\n    let segment = this.positionFormats[0];\n    while (segment && value.length >= segment.end) {\n      const segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      const segmentMax = segment.max(value);\n      if (segmentValue < segment.min) {\n        let toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n      segment = this.positionFormats[segment.end + 1];\n    }\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  }\n\n  formatPastedText(text: string, value: string, cursorStart: number, cursorEnd: number): string {\n    const keyArr = text.trim().split('');\n\n    let position = cursorStart;\n\n    let formattedValue = value;\n    // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (const key of keyArr) {\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      const result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  }\n\n  processKey(initialValue: string, key: string, initialPosition: number) {\n    let value = initialValue;\n    let position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      const result = this.handleSeparatorInput(value, position);\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      const isCursorAtEnd = position === value.length;\n      const segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      const segmentMaxValue = this.getSegmentMaxValue(value, position);\n      const segmentMinValue = this.getSegmentMinValue(value, position);\n      const firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      const isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      const exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, `0${key}`, position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value);\n\n    // Move cursor in front of separator if behind after overwriting a character\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return { value, position };\n  }\n\n  private padWithDefaultValue(segmentValue: string, segment: FormatSegmentFull) {\n    let defaultValue = (segment.default || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  }\n\n  private enrichSegmentDefinitions(segments: FormatSegment[]) {\n    this.positionFormats = {};\n    this.segments = [];\n    let position = 0;\n    for (const segment of segments) {\n      const max = segment.max;\n      const fullSegment: FormatSegmentFull = {\n        ...segment,\n        max: typeof max === 'number' ? () => max : max,\n        start: position,\n        end: position + segment.length,\n      };\n      this.segments.push(fullSegment);\n      // insert this format segment for every char in the max value\n      for (let j = 0; j < fullSegment.length; j++) {\n        this.positionFormats[position++] = fullSegment;\n      }\n      // skip a position for separator\n      position++;\n    }\n  }\n}\n\nexport default MaskFormat;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}