{"ast":null,"code":"var _a, _b, _c;\nimport { __spreadArray } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState } from 'react';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { getTrackableValue } from './utils';\nimport selectionStyles from './selection-control/styles.css.js';\nimport { joinStrings } from '../internal/utils/strings';\nvar SELECTION_ITEM = 'selection-item';\nvar SELECTION_ROOT = 'selection-root';\nfunction findSelectionControlByIndex(rootContainer, index) {\n  if (index === -1) {\n    // find \"select all\" checkbox\n    return rootContainer.querySelector(\"[data-\".concat(SELECTION_ITEM, \"=\\\"all\\\"] .\").concat(selectionStyles.root, \" input\"));\n  }\n  return rootContainer.querySelectorAll(\"[data-\".concat(SELECTION_ITEM, \"=\\\"item\\\"] .\").concat(selectionStyles.root, \" input\"))[index];\n}\nfunction findRootContainer(element) {\n  return findUpUntil(element, function (node) {\n    return node.dataset.selectionRoot === 'true';\n  });\n}\nexport function useFocusMove(selectionType, totalItems) {\n  if (selectionType !== 'multi') {\n    return {};\n  }\n  function moveFocus(sourceElement, fromIndex, direction) {\n    var index = fromIndex;\n    var rootContainer = findRootContainer(sourceElement);\n    while (index >= -1 && index < totalItems) {\n      index += direction;\n      var control = findSelectionControlByIndex(rootContainer, index);\n      if (control && !control.disabled) {\n        control.focus();\n        break;\n      }\n    }\n  }\n  var _a = [1, -1].map(function (direction) {\n      return function (event) {\n        var target = event.currentTarget;\n        var itemNode = findUpUntil(target, function (node) {\n          return node.dataset.selectionItem === 'item';\n        });\n        var fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);\n        moveFocus(target, fromIndex, direction);\n      };\n    }),\n    moveFocusDown = _a[0],\n    moveFocusUp = _a[1];\n  return {\n    moveFocusDown: moveFocusDown,\n    moveFocusUp: moveFocusUp,\n    moveFocus: moveFocus\n  };\n}\n// A set, that compares items by their \"trackables\" (the results of applying `trackBy` to them)\nvar ItemSet = /** @class */function () {\n  function ItemSet(trackBy, items) {\n    var _this = this;\n    this.map = new Map();\n    this.put = function (item) {\n      return _this.map.set.call(_this.map, getTrackableValue(_this.trackBy, item), item);\n    };\n    this.has = function (item) {\n      return _this.map.has.call(_this.map, getTrackableValue(_this.trackBy, item));\n    };\n    this.forEach = this.map.forEach.bind(this.map);\n    this.trackBy = trackBy;\n    items.forEach(this.put);\n  }\n  return ItemSet;\n}();\nexport var focusMarkers = {\n  item: (_a = {}, _a['data-' + SELECTION_ITEM] = 'item', _a),\n  all: (_b = {}, _b['data-' + SELECTION_ITEM] = 'all', _b),\n  root: (_c = {}, _c['data-' + SELECTION_ROOT] = 'true', _c)\n};\nexport function useSelection(_a) {\n  var _b;\n  var items = _a.items,\n    _c = _a.selectedItems,\n    selectedItems = _c === void 0 ? [] : _c,\n    selectionType = _a.selectionType,\n    _d = _a.isItemDisabled,\n    isItemDisabled = _d === void 0 ? function () {\n      return false;\n    } : _d,\n    trackBy = _a.trackBy,\n    onSelectionChange = _a.onSelectionChange,\n    ariaLabels = _a.ariaLabels;\n  var _e = useState(false),\n    shiftPressed = _e[0],\n    setShiftPressed = _e[1];\n  var _f = useState(null),\n    lastClickedItem = _f[0],\n    setLastClickedItem = _f[1];\n  var selectionName = useUniqueId();\n  var finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  var selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  var itemIndexesMap = new Map();\n  items.forEach(function (item, i) {\n    return itemIndexesMap.set(getTrackableValue(trackBy, item), i);\n  });\n  var isItemSelected = selectedSet.has.bind(selectedSet);\n  var getItemState = function (item) {\n    return {\n      disabled: isItemDisabled(item),\n      selected: isItemSelected(item)\n    };\n  };\n  var _g = selectionType ? items.reduce(function (_a, item) {\n      var allDisabled = _a[0],\n        allEnabledSelected = _a[1];\n      var _b = getItemState(item),\n        disabled = _b.disabled,\n        selected = _b.selected;\n      return [\n      // all items are disabled (or none are present)\n      allDisabled && disabled,\n      // all enabled items are selected (or none are present)\n      allEnabledSelected && (selected || disabled)];\n    }, [true, true]) : [true, true],\n    allDisabled = _g[0],\n    allEnabledSelected = _g[1];\n  // the page has at least one selected item\n  var hasSelected = finalSelectedItems.length > 0;\n  var handleToggleAll = function () {\n    var requestedItems = new ItemSet(trackBy, items);\n    var newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, {\n      selectedItems: newSelectedItems\n    });\n  };\n  var getRequestedItems = function (item) {\n    var requestedItems = new ItemSet(trackBy, [item]);\n    var lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    }\n    // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      var currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));\n      var start = Math.min(currentItemIndex, lastClickedItemIndex);\n      var end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(function (item) {\n        return requestedItems.put(item);\n      });\n    }\n    return requestedItems;\n  };\n  var deselectItems = function (requestedItems) {\n    var newSelectedItems = [];\n    selectedItems.forEach(function (selectedItem) {\n      var toUnselect = requestedItems.has(selectedItem);\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n  var selectItems = function (requestedItems) {\n    var newSelectedItems = __spreadArray([], selectedItems, true);\n    requestedItems.forEach(function (newItem) {\n      var _a = getItemState(newItem),\n        selected = _a.selected,\n        disabled = _a.disabled;\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n  var handleToggleItem = function (item) {\n    return function () {\n      var _a = getItemState(item),\n        disabled = _a.disabled,\n        selected = _a.selected;\n      if (disabled || selectionType === 'single' && selected) {\n        return;\n      }\n      if (selectionType === 'single') {\n        fireNonCancelableEvent(onSelectionChange, {\n          selectedItems: [item]\n        });\n      } else {\n        var requestedItems = getRequestedItems(item);\n        var selectedItems_1 = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n        fireNonCancelableEvent(onSelectionChange, {\n          selectedItems: selectedItems_1\n        });\n        setLastClickedItem(item);\n      }\n    };\n  };\n  return {\n    isItemSelected: isItemSelected,\n    selectAllProps: {\n      name: selectionName,\n      disabled: allDisabled,\n      selectionType: selectionType,\n      indeterminate: hasSelected && !allEnabledSelected,\n      checked: hasSelected && allEnabledSelected,\n      onChange: handleToggleAll,\n      ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, {\n        selectedItems: selectedItems\n      }))\n    },\n    getItemSelectionProps: function (item) {\n      var _a;\n      return {\n        name: selectionName,\n        selectionType: selectionType,\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems: selectedItems\n        }, item)),\n        onChange: handleToggleItem(item),\n        checked: isItemSelected(item),\n        disabled: isItemDisabled(item)\n      };\n    },\n    updateShiftToggle: function (value) {\n      setShiftPressed(value);\n    }\n  };\n}","map":{"version":3,"mappings":";;AAAA;AACA;AACA,SAAwBA,QAAQ,QAAQ,OAAO;AAC/C,SAASC,sBAAsB,QAAQ,oBAAoB;AAC3D,SAASC,WAAW,QAAQ,iCAAiC;AAC7D,SAASC,WAAW,QAAQ,uBAAuB;AAEnD,SAASC,iBAAiB,QAAQ,SAAS;AAC3C,OAAOC,eAAe,MAAM,mCAAmC;AAC/D,SAASC,WAAW,QAAQ,2BAA2B;AAEvD,IAAMC,cAAc,GAAG,gBAAgB;AACvC,IAAMC,cAAc,GAAG,gBAAgB;AAEvC,SAASC,2BAA2B,CAACC,aAA0B,EAAEC,KAAa;EAC5E,IAAIA,KAAK,KAAK,CAAC,CAAC,EAAE;IAChB;IACA,OAAOD,aAAa,CAACE,aAAa,CAChC,gBAASL,cAAc,wBAAYF,eAAe,CAACQ,IAAI,WAAQ,CAChE;;EAEH,OAAOH,aAAa,CAACI,gBAAgB,CACnC,gBAASP,cAAc,yBAAaF,eAAe,CAACQ,IAAI,WAAQ,CACjE,CAACF,KAAK,CAAC;AACV;AAEA,SAASI,iBAAiB,CAACC,OAAoB;EAC7C,OAAOb,WAAW,CAACa,OAAO,EAAE,cAAI;IAAI,WAAI,CAACC,OAAO,CAACC,aAAa,KAAK,MAAM;EAArC,CAAqC,CAAE;AAC7E;AAEA,OAAM,SAAUC,YAAY,CAACC,aAA0C,EAAEC,UAAkB;EACzF,IAAID,aAAa,KAAK,OAAO,EAAE;IAC7B,OAAO,EAAE;;EAEX,SAASE,SAAS,CAACC,aAA0B,EAAEC,SAAiB,EAAEC,SAAiB;IACjF,IAAId,KAAK,GAAGa,SAAS;IACrB,IAAMd,aAAa,GAAGK,iBAAiB,CAACQ,aAAa,CAAC;IAEtD,OAAOZ,KAAK,IAAI,CAAC,CAAC,IAAIA,KAAK,GAAGU,UAAU,EAAE;MACxCV,KAAK,IAAIc,SAAS;MAClB,IAAMC,OAAO,GAAGjB,2BAA2B,CAACC,aAAa,EAAEC,KAAK,CAAC;MACjE,IAAIe,OAAO,IAAI,CAACA,OAAO,CAACC,QAAQ,EAAE;QAChCD,OAAO,CAACE,KAAK,EAAE;QACf;;;EAGN;EACM,SAAgC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAW,CAACC,GAAG,CAAC,mBAAS;MACnE,OAAO,UAACC,KAAoB;QAC1B,IAAMC,MAAM,GAAGD,KAAK,CAACE,aAA4B;QACjD,IAAMC,QAAQ,GAAG9B,WAAW,CAAC4B,MAAM,EAAE,cAAI;UAAI,WAAI,CAACd,OAAO,CAACiB,aAAa,KAAK,MAAM;QAArC,CAAqC,CAAE;QACpF,IAAMV,SAAS,GAAGW,KAAK,CAACC,SAAS,CAACC,OAAO,CAACC,IAAI,CAACL,QAAQ,CAACM,aAAc,CAACC,QAAQ,EAAEP,QAAQ,CAAC;QAC1FX,SAAS,CAACS,MAAM,EAAEP,SAAS,EAAEC,SAAS,CAAC;MACzC,CAAC;IACH,CAAC,CAAC;IAPKgB,aAAa;IAAEC,WAAW,QAO/B;EACF,OAAO;IACLD,aAAa;IACbC,WAAW;IACXpB,SAAS;GACV;AACH;AAEA;AACA;EACE,iBAAYqB,OAA0C,EAAEC,KAAuB;IAA/E;IAKQ,QAAG,GAAoB,IAAIC,GAAG,EAAE;IACxC,QAAG,GAAG,UAACC,IAAO;MAAK,YAAI,CAACjB,GAAG,CAACkB,GAAG,CAACT,IAAI,CAACU,KAAI,CAACnB,GAAG,EAAEzB,iBAAiB,CAAC4C,KAAI,CAACL,OAAO,EAAEG,IAAI,CAAC,EAAEA,IAAI,CAAC;IAAxE,CAAwE;IAC3F,QAAG,GAAG,UAACA,IAAO;MAAK,YAAI,CAACjB,GAAG,CAACoB,GAAG,CAACX,IAAI,CAACU,KAAI,CAACnB,GAAG,EAAEzB,iBAAiB,CAAC4C,KAAI,CAACL,OAAO,EAAEG,IAAI,CAAC,CAAC;IAAlE,CAAkE;IACrF,YAAO,GAAG,IAAI,CAACjB,GAAG,CAACqB,OAAO,CAACC,IAAI,CAAC,IAAI,CAACtB,GAAG,CAAC;IAPvC,IAAI,CAACc,OAAO,GAAGA,OAAO;IACtBC,KAAK,CAACM,OAAO,CAAC,IAAI,CAACE,GAAG,CAAC;EACzB;EAMF,cAAC;AAAD,CAAC,EAVD;AAYA,OAAO,IAAMC,YAAY,GAAG;EAC1BP,IAAI,YAAIQ,GAAC,OAAO,GAAG/C,cAAc,IAAG,MAAM,KAAE;EAC5CgD,GAAG,YAAIC,GAAC,OAAO,GAAGjD,cAAc,IAAG,KAAK,KAAE;EAC1CM,IAAI,YAAI4C,GAAC,OAAO,GAAGjD,cAAc,IAAG,MAAM;CAC3C;AAED,OAAM,SAAUkD,YAAY,CAAIJ,EAW/B;;MAVCV,KAAK;IACLa,qBAAkB;IAAlBE,aAAa,mBAAG,EAAE;IAClBvC,aAAa;IACbwC,sBAA4B;IAA5BC,cAAc,mBAAG;MAAM,YAAK;IAAL,CAAK;IAC5BlB,OAAO;IACPmB,iBAAiB;IACjBC,UAAU;EAKJ,SAAkC/D,QAAQ,CAAC,KAAK,CAAC;IAAhDgE,YAAY;IAAEC,eAAe,QAAmB;EACjD,SAAwCjE,QAAQ,CAAW,IAAI,CAAC;IAA/DkE,eAAe;IAAEC,kBAAkB,QAA4B;EACtE,IAAMC,aAAa,GAAGlE,WAAW,EAAE;EACnC,IAAMmE,kBAAkB,GAAGjD,aAAa,KAAK,QAAQ,GAAGuC,aAAa,CAACW,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGX,aAAa;EACjG,IAAMY,WAAW,GAAG,IAAIC,OAAO,CAAC7B,OAAO,EAAE0B,kBAAkB,CAAC;EAC5D,IAAMI,cAAc,GAAG,IAAI5B,GAAG,EAAE;EAChCD,KAAK,CAACM,OAAO,CAAC,UAACJ,IAAI,EAAE4B,CAAC;IAAK,qBAAc,CAAC3B,GAAG,CAAC3C,iBAAiB,CAACuC,OAAO,EAAEG,IAAI,CAAC,EAAE4B,CAAC,CAAC;EAAvD,CAAuD,CAAC;EACnF,IAAMC,cAAc,GAAGJ,WAAW,CAACtB,GAAG,CAACE,IAAI,CAACoB,WAAW,CAAC;EACxD,IAAMK,YAAY,GAAG,UAAC9B,IAAO;IAAK,OAAC;MACjCnB,QAAQ,EAAEkC,cAAc,CAACf,IAAI,CAAC;MAC9B+B,QAAQ,EAAEF,cAAc,CAAC7B,IAAI;KAC9B;EAHiC,CAGhC;EACI,SAAoC1B,aAAa,GACnDwB,KAAK,CAACkC,MAAM,CACV,UAACxB,EAAiC,EAAER,IAAI;UAAtCiC,WAAW;QAAEC,kBAAkB;MACzB,SAAyBJ,YAAY,CAAC9B,IAAI,CAAC;QAAzCnB,QAAQ;QAAEkD,QAAQ,cAAuB;MACjD,OAAO;MACL;MACAE,WAAW,IAAIpD,QAAQ;MACvB;MACAqD,kBAAkB,KAAKH,QAAQ,IAAIlD,QAAQ,CAAC,CAC7C;IACH,CAAC,EACD,CAAC,IAAI,EAAE,IAAI,CAAC,CACb,GACD,CAAC,IAAI,EAAE,IAAI,CAAC;IAbToD,WAAW;IAAEC,kBAAkB,QAatB;EAEhB;EACA,IAAMC,WAAW,GAAGZ,kBAAkB,CAACa,MAAM,GAAG,CAAC;EAEjD,IAAMC,eAAe,GAAG;IACtB,IAAMC,cAAc,GAAG,IAAIZ,OAAO,CAAC7B,OAAO,EAAEC,KAAK,CAAC;IAClD,IAAMyC,gBAAgB,GAAGL,kBAAkB,GAAGM,aAAa,CAACF,cAAc,CAAC,GAAGG,WAAW,CAACH,cAAc,CAAC;IACzGnF,sBAAsB,CAAC6D,iBAAiB,EAAE;MAAEH,aAAa,EAAE0B;IAAgB,CAAE,CAAC;EAChF,CAAC;EAED,IAAMG,iBAAiB,GAAG,UAAC1C,IAAO;IAChC,IAAMsC,cAAc,GAAG,IAAIZ,OAAO,CAAC7B,OAAO,EAAE,CAACG,IAAI,CAAC,CAAC;IACnD,IAAI2C,oBAAoB,GAAGvB,eAAe,GAAGO,cAAc,CAACiB,GAAG,CAACtF,iBAAiB,CAACuC,OAAO,EAAEuB,eAAe,CAAC,CAAC,GAAG,CAAC,CAAC;IACjH,IAAIuB,oBAAoB,KAAKE,SAAS,EAAE;MACtCF,oBAAoB,GAAG,CAAC,CAAC;;IAE3B;IACA;IACA,IAAIzB,YAAY,IAAIyB,oBAAoB,KAAK,CAAC,CAAC,EAAE;MAC/C;MACA,IAAMG,gBAAgB,GAAGnB,cAAc,CAACiB,GAAG,CAACtF,iBAAiB,CAACuC,OAAO,EAAEG,IAAI,CAAC,CAAW;MACvF,IAAM+C,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACH,gBAAgB,EAAEH,oBAAoB,CAAC;MAC9D,IAAMO,GAAG,GAAGF,IAAI,CAACG,GAAG,CAACL,gBAAgB,EAAEH,oBAAoB,CAAC;MAC5D7C,KAAK,CAAC0B,KAAK,CAACuB,KAAK,EAAEG,GAAG,GAAG,CAAC,CAAC,CAAC9C,OAAO,CAAC,cAAI;QAAI,qBAAc,CAACE,GAAG,CAACN,IAAI,CAAC;MAAxB,CAAwB,CAAC;;IAEvE,OAAOsC,cAAc;EACvB,CAAC;EAED,IAAME,aAAa,GAAG,UAACF,cAA0B;IAC/C,IAAMC,gBAAgB,GAAa,EAAE;IACrC1B,aAAa,CAACT,OAAO,CAAC,sBAAY;MAChC,IAAMgD,UAAU,GAAGd,cAAc,CAACnC,GAAG,CAACkD,YAAY,CAAC;MACnD,IAAI,CAACD,UAAU,IAAIrC,cAAc,CAACsC,YAAY,CAAC,EAAE;QAC/Cd,gBAAgB,CAACe,IAAI,CAACD,YAAY,CAAC;;IAEvC,CAAC,CAAC;IACF,OAAOd,gBAAgB;EACzB,CAAC;EAED,IAAME,WAAW,GAAG,UAACH,cAA0B;IAC7C,IAAMC,gBAAgB,qBAAO1B,aAAa,OAAC;IAC3CyB,cAAc,CAAClC,OAAO,CAAC,iBAAO;MACtB,SAAyB0B,YAAY,CAACyB,OAAO,CAAC;QAA5CxB,QAAQ;QAAElD,QAAQ,cAA0B;MACpD,IAAI,CAACkD,QAAQ,IAAI,CAAClD,QAAQ,EAAE;QAC1B0D,gBAAgB,CAACe,IAAI,CAACC,OAAO,CAAC;;IAElC,CAAC,CAAC;IACF,OAAOhB,gBAAgB;EACzB,CAAC;EAED,IAAMiB,gBAAgB,GAAG,UAACxD,IAAO;IAAK;MAC9B,SAAyB8B,YAAY,CAAC9B,IAAI,CAAC;QAAzCnB,QAAQ;QAAEkD,QAAQ,cAAuB;MACjD,IAAIlD,QAAQ,IAAKP,aAAa,KAAK,QAAQ,IAAIyD,QAAS,EAAE;QACxD;;MAEF,IAAIzD,aAAa,KAAK,QAAQ,EAAE;QAC9BnB,sBAAsB,CAAC6D,iBAAiB,EAAE;UAAEH,aAAa,EAAE,CAACb,IAAI;QAAC,CAAE,CAAC;OACrE,MAAM;QACL,IAAMsC,cAAc,GAAGI,iBAAiB,CAAC1C,IAAI,CAAC;QAC9C,IAAMyD,eAAa,GAAG1B,QAAQ,GAAGS,aAAa,CAACF,cAAc,CAAC,GAAGG,WAAW,CAACH,cAAc,CAAC;QAC5FnF,sBAAsB,CAAC6D,iBAAiB,EAAE;UAAEH,aAAa;QAAA,CAAE,CAAC;QAC5DQ,kBAAkB,CAACrB,IAAI,CAAC;;IAE5B,CAAC;EAbqC,CAarC;EACD,OAAO;IACL6B,cAAc;IACd6B,cAAc,EAAE;MACdC,IAAI,EAAErC,aAAa;MACnBzC,QAAQ,EAAEoD,WAAW;MACrB3D,aAAa,EAAEA,aAAa;MAC5BsF,aAAa,EAAEzB,WAAW,IAAI,CAACD,kBAAkB;MACjD2B,OAAO,EAAE1B,WAAW,IAAID,kBAAkB;MAC1C4B,QAAQ,EAAEzB,eAAe;MACzB0B,SAAS,EAAEvG,WAAW,CAACyD,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+C,mBAAmB,EAAE,gBAAU,aAAV/C,UAAU,uBAAVA,UAAU,CAAEgD,sBAAsB,2DAAG;QAAEpD,aAAa;MAAA,CAAE,CAAC;KAChH;IACDqD,qBAAqB,EAAE,UAAClE,IAAO;;MAAK,OAAC;QACnC2D,IAAI,EAAErC,aAAa;QACnBhD,aAAa,EAAEA,aAAa;QAC5ByF,SAAS,EAAEvG,WAAW,CACpByD,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+C,mBAAmB,EAC/B,gBAAU,aAAV/C,UAAU,uBAAVA,UAAU,CAAEkD,kBAAkB,2DAAG;UAAEtD,aAAa;QAAA,CAAE,EAAEb,IAAI,CAAC,CAC1D;QACD8D,QAAQ,EAAEN,gBAAgB,CAACxD,IAAI,CAAC;QAChC6D,OAAO,EAAEhC,cAAc,CAAC7B,IAAI,CAAC;QAC7BnB,QAAQ,EAAEkC,cAAc,CAACf,IAAI;OAC9B;KAAC;IACFoE,iBAAiB,EAAE,UAACC,KAAc;MAChClD,eAAe,CAACkD,KAAK,CAAC;IACxB;GACD;AACH","names":["useState","fireNonCancelableEvent","useUniqueId","findUpUntil","getTrackableValue","selectionStyles","joinStrings","SELECTION_ITEM","SELECTION_ROOT","findSelectionControlByIndex","rootContainer","index","querySelector","root","querySelectorAll","findRootContainer","element","dataset","selectionRoot","useFocusMove","selectionType","totalItems","moveFocus","sourceElement","fromIndex","direction","control","disabled","focus","map","event","target","currentTarget","itemNode","selectionItem","Array","prototype","indexOf","call","parentElement","children","moveFocusDown","moveFocusUp","trackBy","items","Map","item","set","_this","has","forEach","bind","put","focusMarkers","_a","all","_b","_c","useSelection","selectedItems","_d","isItemDisabled","onSelectionChange","ariaLabels","shiftPressed","setShiftPressed","lastClickedItem","setLastClickedItem","selectionName","finalSelectedItems","slice","selectedSet","ItemSet","itemIndexesMap","i","isItemSelected","getItemState","selected","reduce","allDisabled","allEnabledSelected","hasSelected","length","handleToggleAll","requestedItems","newSelectedItems","deselectItems","selectItems","getRequestedItems","lastClickedItemIndex","get","undefined","currentItemIndex","start","Math","min","end","max","toUnselect","selectedItem","push","newItem","handleToggleItem","selectedItems_1","selectAllProps","name","indeterminate","checked","onChange","ariaLabel","selectionGroupLabel","allItemsSelectionLabel","getItemSelectionProps","itemSelectionLabel","updateShiftToggle","value"],"sources":["/Users/dcastro/node_modules/src/table/use-selection.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { KeyboardEvent, useState } from 'react';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { TableProps } from './interfaces';\nimport { getTrackableValue } from './utils';\nimport selectionStyles from './selection-control/styles.css.js';\nimport { joinStrings } from '../internal/utils/strings';\n\nconst SELECTION_ITEM = 'selection-item';\nconst SELECTION_ROOT = 'selection-root';\n\nfunction findSelectionControlByIndex(rootContainer: HTMLElement, index: number) {\n  if (index === -1) {\n    // find \"select all\" checkbox\n    return rootContainer.querySelector<HTMLInputElement>(\n      `[data-${SELECTION_ITEM}=\"all\"] .${selectionStyles.root} input`\n    );\n  }\n  return rootContainer.querySelectorAll<HTMLInputElement>(\n    `[data-${SELECTION_ITEM}=\"item\"] .${selectionStyles.root} input`\n  )[index];\n}\n\nfunction findRootContainer(element: HTMLElement) {\n  return findUpUntil(element, node => node.dataset.selectionRoot === 'true')!;\n}\n\nexport function useFocusMove(selectionType: TableProps['selectionType'], totalItems: number) {\n  if (selectionType !== 'multi') {\n    return {};\n  }\n  function moveFocus(sourceElement: HTMLElement, fromIndex: number, direction: -1 | 1) {\n    let index = fromIndex;\n    const rootContainer = findRootContainer(sourceElement);\n\n    while (index >= -1 && index < totalItems) {\n      index += direction;\n      const control = findSelectionControlByIndex(rootContainer, index);\n      if (control && !control.disabled) {\n        control.focus();\n        break;\n      }\n    }\n  }\n  const [moveFocusDown, moveFocusUp] = ([1, -1] as const).map(direction => {\n    return (event: KeyboardEvent) => {\n      const target = event.currentTarget as HTMLElement;\n      const itemNode = findUpUntil(target, node => node.dataset.selectionItem === 'item')!;\n      const fromIndex = Array.prototype.indexOf.call(itemNode.parentElement!.children, itemNode);\n      moveFocus(target, fromIndex, direction);\n    };\n  });\n  return {\n    moveFocusDown,\n    moveFocusUp,\n    moveFocus,\n  };\n}\n\n// A set, that compares items by their \"trackables\" (the results of applying `trackBy` to them)\nclass ItemSet<T> {\n  constructor(trackBy: TableProps.TrackBy<T> | undefined, items: ReadonlyArray<T>) {\n    this.trackBy = trackBy;\n    items.forEach(this.put);\n  }\n  private trackBy: TableProps.TrackBy<T> | undefined;\n  private map: Map<unknown, T> = new Map();\n  put = (item: T) => this.map.set.call(this.map, getTrackableValue(this.trackBy, item), item);\n  has = (item: T) => this.map.has.call(this.map, getTrackableValue(this.trackBy, item));\n  forEach = this.map.forEach.bind(this.map);\n}\n\nexport const focusMarkers = {\n  item: { ['data-' + SELECTION_ITEM]: 'item' },\n  all: { ['data-' + SELECTION_ITEM]: 'all' },\n  root: { ['data-' + SELECTION_ROOT]: 'true' },\n};\n\nexport function useSelection<T>({\n  items,\n  selectedItems = [],\n  selectionType,\n  isItemDisabled = () => false,\n  trackBy,\n  onSelectionChange,\n  ariaLabels,\n}: Pick<\n  TableProps<T>,\n  'ariaLabels' | 'items' | 'selectedItems' | 'selectionType' | 'isItemDisabled' | 'trackBy' | 'onSelectionChange'\n>) {\n  const [shiftPressed, setShiftPressed] = useState(false);\n  const [lastClickedItem, setLastClickedItem] = useState<T | null>(null);\n  const selectionName = useUniqueId();\n  const finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  const selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  const itemIndexesMap = new Map();\n  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));\n  const isItemSelected = selectedSet.has.bind(selectedSet);\n  const getItemState = (item: T) => ({\n    disabled: isItemDisabled(item),\n    selected: isItemSelected(item),\n  });\n  const [allDisabled, allEnabledSelected] = selectionType\n    ? items.reduce(\n        ([allDisabled, allEnabledSelected], item) => {\n          const { disabled, selected } = getItemState(item);\n          return [\n            // all items are disabled (or none are present)\n            allDisabled && disabled,\n            // all enabled items are selected (or none are present)\n            allEnabledSelected && (selected || disabled),\n          ];\n        },\n        [true, true]\n      )\n    : [true, true];\n\n  // the page has at least one selected item\n  const hasSelected = finalSelectedItems.length > 0;\n\n  const handleToggleAll = () => {\n    const requestedItems = new ItemSet(trackBy, items);\n    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });\n  };\n\n  const getRequestedItems = (item: T) => {\n    const requestedItems = new ItemSet(trackBy, [item]);\n    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    }\n    // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item)) as number;\n      const start = Math.min(currentItemIndex, lastClickedItemIndex);\n      const end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(item => requestedItems.put(item));\n    }\n    return requestedItems;\n  };\n\n  const deselectItems = (requestedItems: ItemSet<T>) => {\n    const newSelectedItems: Array<T> = [];\n    selectedItems.forEach(selectedItem => {\n      const toUnselect = requestedItems.has(selectedItem);\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const selectItems = (requestedItems: ItemSet<T>) => {\n    const newSelectedItems = [...selectedItems];\n    requestedItems.forEach(newItem => {\n      const { selected, disabled } = getItemState(newItem);\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  const handleToggleItem = (item: T) => () => {\n    const { disabled, selected } = getItemState(item);\n    if (disabled || (selectionType === 'single' && selected)) {\n      return;\n    }\n    if (selectionType === 'single') {\n      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });\n    } else {\n      const requestedItems = getRequestedItems(item);\n      const selectedItems = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n      fireNonCancelableEvent(onSelectionChange, { selectedItems });\n      setLastClickedItem(item);\n    }\n  };\n  return {\n    isItemSelected,\n    selectAllProps: {\n      name: selectionName,\n      disabled: allDisabled,\n      selectionType: selectionType,\n      indeterminate: hasSelected && !allEnabledSelected,\n      checked: hasSelected && allEnabledSelected,\n      onChange: handleToggleAll,\n      ariaLabel: joinStrings(ariaLabels?.selectionGroupLabel, ariaLabels?.allItemsSelectionLabel?.({ selectedItems })),\n    },\n    getItemSelectionProps: (item: T) => ({\n      name: selectionName,\n      selectionType: selectionType,\n      ariaLabel: joinStrings(\n        ariaLabels?.selectionGroupLabel,\n        ariaLabels?.itemSelectionLabel?.({ selectedItems }, item)\n      ),\n      onChange: handleToggleItem(item),\n      checked: isItemSelected(item),\n      disabled: isItemDisabled(item),\n    }),\n    updateShiftToggle: (value: boolean) => {\n      setShiftPressed(value);\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}