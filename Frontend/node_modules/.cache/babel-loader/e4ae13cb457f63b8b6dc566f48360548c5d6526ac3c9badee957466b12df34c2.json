{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer';\nimport { useEffect, useLayoutEffect } from 'react';\nimport { useStableEventHandler } from '../use-stable-event-handler';\n/**\n * Attaches resize-observer to the referenced element.\n *\n * Examples:\n *     // With React reference\n *     const ref = useRef(null)\n *     useResizeObserver(ref, (entry) => setState(getWidth(entry)))\n *\n *     // With ID reference\n *     const getElement = useCallback(() => document.getElementById(id), [id])\n *     useResizeObserver(getElement, (entry) => setState(getWidth(entry)))\n *\n * @param elementRef React reference or memoized getter for the target element\n * @param onObserve Function to fire when observation occurs\n */\nexport function useResizeObserver(elementRef, onObserve) {\n  var stableOnObserve = useStableEventHandler(onObserve);\n  // This effect provides a synchronous update required to prevent flakiness when initial state and first observed state are different.\n  // Can potentially conflict with React concurrent mode: https://17.reactjs.org/docs/concurrent-mode-intro.html.\n  // A possible solution would be to make consumers not render any content until the first (asynchronous) observation is available.\n  useLayoutEffect(function () {\n    var element = typeof elementRef === 'function' ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n    if (element) {\n      onObserve(convertResizeObserverEntry(new ResizeObserverEntry(element)));\n    }\n  },\n  // This effect is only needed for the first render to provide a synchronous update.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useEffect(function () {\n    var element = typeof elementRef === 'function' ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n    if (element) {\n      var connected_1 = true;\n      var observer_1 = new ResizeObserver(function (entries) {\n        // Prevent observe notifications on already unmounted component.\n        if (connected_1) {\n          stableOnObserve(convertResizeObserverEntry(entries[0]));\n        }\n      });\n      observer_1.observe(element);\n      return function () {\n        connected_1 = false;\n        observer_1.disconnect();\n      };\n    }\n  }, [elementRef, stableOnObserve]);\n}\nfunction convertResizeObserverEntry(entry) {\n  return {\n    target: entry.target,\n    contentBoxWidth: entry.contentBoxSize[0].inlineSize,\n    contentBoxHeight: entry.contentBoxSize[0].blockSize,\n    borderBoxWidth: entry.borderBoxSize[0].inlineSize,\n    borderBoxHeight: entry.borderBoxSize[0].blockSize,\n    width: entry.contentBoxSize[0].inlineSize,\n    height: entry.contentBoxSize[0].blockSize\n  };\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,SAASA,cAAc,EAAEC,mBAAmB,QAAQ,yBAAyB;AAC7E,SAAgBC,SAAS,EAAEC,eAAe,QAAQ,OAAO;AACzD,SAASC,qBAAqB,QAAQ,6BAA6B;AAKnE;;;;;;;;;;;;;;;AAeA,OAAM,SAAUC,iBAAiB,CAACC,UAA4B,EAAEC,SAA+C;EAC7G,IAAMC,eAAe,GAAGJ,qBAAqB,CAACG,SAAS,CAAC;EAExD;EACA;EACA;EACAJ,eAAe,CACb;IACE,IAAMM,OAAO,GAAG,OAAOH,UAAU,KAAK,UAAU,GAAGA,UAAU,EAAE,GAAGA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEI,OAAO;IACrF,IAAID,OAAO,EAAE;MACXF,SAAS,CAACI,0BAA0B,CAAC,IAAIV,mBAAmB,CAACQ,OAAO,CAAC,CAAC,CAAC;;EAE3E,CAAC;EACD;EACA;EACA,EAAE,CACH;EAEDP,SAAS,CAAC;IACR,IAAMO,OAAO,GAAG,OAAOH,UAAU,KAAK,UAAU,GAAGA,UAAU,EAAE,GAAGA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEI,OAAO;IACrF,IAAID,OAAO,EAAE;MACX,IAAIG,WAAS,GAAG,IAAI;MACpB,IAAMC,UAAQ,GAAG,IAAIb,cAAc,CAAC,iBAAO;QACzC;QACA,IAAIY,WAAS,EAAE;UACbJ,eAAe,CAACG,0BAA0B,CAACG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;;MAE3D,CAAC,CAAC;MACFD,UAAQ,CAACE,OAAO,CAACN,OAAO,CAAC;MACzB,OAAO;QACLG,WAAS,GAAG,KAAK;QACjBC,UAAQ,CAACG,UAAU,EAAE;MACvB,CAAC;;EAEL,CAAC,EAAE,CAACV,UAAU,EAAEE,eAAe,CAAC,CAAC;AACnC;AAEA,SAASG,0BAA0B,CAACM,KAA0B;EAC5D,OAAO;IACLC,MAAM,EAAED,KAAK,CAACC,MAAM;IACpBC,eAAe,EAAEF,KAAK,CAACG,cAAc,CAAC,CAAC,CAAC,CAACC,UAAU;IACnDC,gBAAgB,EAAEL,KAAK,CAACG,cAAc,CAAC,CAAC,CAAC,CAACG,SAAS;IACnDC,cAAc,EAAEP,KAAK,CAACQ,aAAa,CAAC,CAAC,CAAC,CAACJ,UAAU;IACjDK,eAAe,EAAET,KAAK,CAACQ,aAAa,CAAC,CAAC,CAAC,CAACF,SAAS;IACjDI,KAAK,EAAEV,KAAK,CAACG,cAAc,CAAC,CAAC,CAAC,CAACC,UAAU;IACzCO,MAAM,EAAEX,KAAK,CAACG,cAAc,CAAC,CAAC,CAAC,CAACG;GACjC;AACH","names":["ResizeObserver","ResizeObserverEntry","useEffect","useLayoutEffect","useStableEventHandler","useResizeObserver","elementRef","onObserve","stableOnObserve","element","current","convertResizeObserverEntry","connected_1","observer_1","entries","observe","disconnect","entry","target","contentBoxWidth","contentBoxSize","inlineSize","contentBoxHeight","blockSize","borderBoxWidth","borderBoxSize","borderBoxHeight","width","height"],"sources":["/Users/dcastro/node_modules/src/internal/hooks/container-queries/use-resize-observer.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer';\nimport React, { useEffect, useLayoutEffect } from 'react';\nimport { useStableEventHandler } from '../use-stable-event-handler';\nimport { ContainerQueryEntry } from './interfaces';\n\ntype ElementReference = (() => Element | null) | React.RefObject<Element>;\n\n/**\n * Attaches resize-observer to the referenced element.\n *\n * Examples:\n *     // With React reference\n *     const ref = useRef(null)\n *     useResizeObserver(ref, (entry) => setState(getWidth(entry)))\n *\n *     // With ID reference\n *     const getElement = useCallback(() => document.getElementById(id), [id])\n *     useResizeObserver(getElement, (entry) => setState(getWidth(entry)))\n *\n * @param elementRef React reference or memoized getter for the target element\n * @param onObserve Function to fire when observation occurs\n */\nexport function useResizeObserver(elementRef: ElementReference, onObserve: (entry: ContainerQueryEntry) => void) {\n  const stableOnObserve = useStableEventHandler(onObserve);\n\n  // This effect provides a synchronous update required to prevent flakiness when initial state and first observed state are different.\n  // Can potentially conflict with React concurrent mode: https://17.reactjs.org/docs/concurrent-mode-intro.html.\n  // A possible solution would be to make consumers not render any content until the first (asynchronous) observation is available.\n  useLayoutEffect(\n    () => {\n      const element = typeof elementRef === 'function' ? elementRef() : elementRef?.current;\n      if (element) {\n        onObserve(convertResizeObserverEntry(new ResizeObserverEntry(element)));\n      }\n    },\n    // This effect is only needed for the first render to provide a synchronous update.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  useEffect(() => {\n    const element = typeof elementRef === 'function' ? elementRef() : elementRef?.current;\n    if (element) {\n      let connected = true;\n      const observer = new ResizeObserver(entries => {\n        // Prevent observe notifications on already unmounted component.\n        if (connected) {\n          stableOnObserve(convertResizeObserverEntry(entries[0]));\n        }\n      });\n      observer.observe(element);\n      return () => {\n        connected = false;\n        observer.disconnect();\n      };\n    }\n  }, [elementRef, stableOnObserve]);\n}\n\nfunction convertResizeObserverEntry(entry: ResizeObserverEntry): ContainerQueryEntry {\n  return {\n    target: entry.target,\n    contentBoxWidth: entry.contentBoxSize[0].inlineSize,\n    contentBoxHeight: entry.contentBoxSize[0].blockSize,\n    borderBoxWidth: entry.borderBoxSize[0].inlineSize,\n    borderBoxHeight: entry.borderBoxSize[0].blockSize,\n    width: entry.contentBoxSize[0].inlineSize,\n    height: entry.contentBoxSize[0].blockSize,\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}