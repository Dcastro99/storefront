{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, createRef, useCallback, useEffect, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { getSplitPanelPosition } from './split-panel';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useContainerQuery, useResizeObserver } from '../../internal/hooks/container-queries';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../../internal/is-development';\nimport { warnOnce } from '../../internal/logging';\nimport { applyDefaults } from '../defaults';\nimport { useFocusControl } from '../utils/use-focus-control';\n// TODO simplify default params + typings\nvar defaults = {\n  breadcrumbs: null,\n  content: null,\n  contentHeader: null,\n  contentType: 'default',\n  disableBodyScroll: false,\n  disableContentHeaderOverlap: false,\n  disableContentPaddings: false,\n  dynamicOverlapHeight: 0,\n  headerHeight: 0,\n  footerHeight: 0,\n  handleNavigationClick: function (value) {\n    return value;\n  },\n  handleSplitPanelClick: function () {},\n  handleSplitPanelPreferencesChange: function () {},\n  handleSplitPanelResize: function () {},\n  handleToolsClick: function (value) {\n    return value;\n  },\n  hasDefaultToolsWidth: true,\n  hasNotificationsContent: false,\n  isAnyPanelOpen: false,\n  isMobile: false,\n  isNavigationOpen: false,\n  isSplitPanelForcedPosition: false,\n  isSplitPanelOpen: false,\n  isToolsOpen: false,\n  // TODO: these refs are currently only instantiated once globally\n  layoutElement: createRef(),\n  layoutWidth: 0,\n  mainElement: createRef(),\n  mainOffsetLeft: 0,\n  maxContentWidth: 0,\n  minContentWidth: 280,\n  navigation: null,\n  navigationHide: false,\n  navigationOpen: false,\n  notifications: null,\n  notificationsElement: createRef(),\n  notificationsHeight: 0,\n  offsetBottom: 0,\n  onNavigationChange: function () {},\n  onSplitPanelResize: function () {},\n  onSplitPanelToggle: function () {},\n  onSplitPanelPreferencesChange: function () {},\n  setDynamicOverlapHeight: function (value) {\n    return void value;\n  },\n  setIsNavigationOpen: function (value) {\n    return value;\n  },\n  setIsToolsOpen: function (value) {\n    return value;\n  },\n  setOffsetBottom: function (value) {\n    return void value;\n  },\n  setSplitPanelReportedSize: function (value) {\n    return void value;\n  },\n  splitPanelMaxWidth: 280,\n  splitPanelMinWidth: 280,\n  splitPanelOpen: false,\n  splitPanelPosition: 'bottom',\n  splitPanelPreferences: {\n    position: 'bottom'\n  },\n  splitPanelReportedSize: 0,\n  splitPanelSize: 0,\n  stickyNotifications: false,\n  tools: null,\n  toolsFocusControl: {}\n};\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\nexport var AppLayoutContext = createContext(__assign({}, defaults));\nexport var AppLayoutProvider = React.forwardRef(function (_a, forwardRef) {\n  var _b, _c, _d;\n  var toolsHide = _a.toolsHide,\n    controlledToolsOpen = _a.toolsOpen,\n    navigationHide = _a.navigationHide,\n    controlledNavigationOpen = _a.navigationOpen,\n    _e = _a.contentType,\n    contentType = _e === void 0 ? 'default' : _e,\n    _f = _a.headerSelector,\n    headerSelector = _f === void 0 ? '#b #h' : _f,\n    _g = _a.footerSelector,\n    footerSelector = _g === void 0 ? '#b #h' : _g,\n    children = _a.children,\n    props = __rest(_a, [\"toolsHide\", \"toolsOpen\", \"navigationHide\", \"navigationOpen\", \"contentType\", \"headerSelector\", \"footerSelector\", \"children\"]);\n  var isMobile = useMobile();\n  if (isDevelopment) {\n    if (controlledToolsOpen && toolsHide) {\n      warnOnce('AppLayout', \"You have enabled both the `toolsOpen` prop and the `toolsHide` prop. This is not supported. Set `toolsOpen` to `false` when you set `toolsHide` to `true`.\");\n    }\n  }\n  /**\n   * The overlap height has a default set in CSS but can also be dynamically overridden\n   * for content types (such as Table and Wizard) that have variable size content in the overlap.\n   */\n  var _h = useState(0),\n    dynamicOverlapHeight = _h[0],\n    setDynamicOverlapHeight = _h[1];\n  /**\n   * Set the default values for minimum and maximum content width.\n   */\n  var geckoMaxCssLength = ((1 << 30) - 1) / 60;\n  var halfGeckoMaxCssLength = geckoMaxCssLength / 2;\n  // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n  // Limit the maxContentWidth to the half of the upper boundary (≈4230^2) to be on the safe side.\n  var maxContentWidth = props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength ? halfGeckoMaxCssLength : (_b = props.maxContentWidth) !== null && _b !== void 0 ? _b : 0;\n  var minContentWidth = (_c = props.minContentWidth) !== null && _c !== void 0 ? _c : 280;\n  /**\n   * Determine the default state of the Navigation and Tools drawers.\n   * Mobile viewports should be closed by default under all circumstances.\n   * If the navigationOpen prop has been set then that should take precedence\n   * over the contentType prop. Desktop viewports that do not have the\n   * navigationOpen or contentType props set will use the default contentType.\n   */\n  var contentTypeDefaults = applyDefaults(contentType, {\n    maxContentWidth: maxContentWidth,\n    minContentWidth: minContentWidth\n  }, true);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Navigation drawer. The logic\n   * for determining the default state is colocated with the Navigation component.\n   *\n   * The callback that will be passed to the Navigation and AppBar\n   * components to handle the click events that will change the state\n   * of the Navigation drawer. It will set the Navigation state with the\n   * useControllable hook and also fire the onNavigationChange function to\n   * emit the state change.\n   */\n  var _j = useControllable(controlledNavigationOpen, props.onNavigationChange, isMobile ? false : contentTypeDefaults.navigationOpen, {\n      componentName: 'AppLayout',\n      controlledProp: 'navigationOpen',\n      changeHandler: 'onNavigationChange'\n    }),\n    _k = _j[0],\n    isNavigationOpen = _k === void 0 ? false : _k,\n    setIsNavigationOpen = _j[1];\n  var handleNavigationClick = useCallback(function handleNavigationChange(isOpen) {\n    setIsNavigationOpen(isOpen);\n    fireNonCancelableEvent(props.onNavigationChange, {\n      open: isOpen\n    });\n  }, [props.onNavigationChange, setIsNavigationOpen]);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Tools drawer. The logic\n   * for determining the default state is colocated with the Tools component.\n   *\n   * The callback that will be passed to the Navigation and AppBar\n   * components to handle the click events that will change the state\n   * of the Tools drawer. It will set the Tools state with the\n   * useControllable hook and also fire the onToolsChange function to\n   * emit the state change.\n   */\n  var toolsWidth = (_d = props.toolsWidth) !== null && _d !== void 0 ? _d : 290;\n  var hasDefaultToolsWidth = props.toolsWidth === undefined;\n  var _l = useControllable(controlledToolsOpen, props.onToolsChange, isMobile ? false : contentTypeDefaults.toolsOpen, {\n      componentName: 'AppLayout',\n      controlledProp: 'toolsOpen',\n      changeHandler: 'onToolsChange'\n    }),\n    _m = _l[0],\n    isToolsOpen = _m === void 0 ? false : _m,\n    setIsToolsOpen = _l[1];\n  var toolsFocusControl = useFocusControl(isToolsOpen, true);\n  var handleToolsClick = useCallback(function handleToolsChange(isOpen) {\n    setIsToolsOpen(isOpen);\n    fireNonCancelableEvent(props.onToolsChange, {\n      open: isOpen\n    });\n  }, [props.onToolsChange, setIsToolsOpen]);\n  var navigationVisible = !navigationHide && isNavigationOpen;\n  var toolsVisible = !toolsHide && isToolsOpen;\n  var isAnyPanelOpen = navigationVisible || toolsVisible;\n  /**\n   * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n   * that consumes 100% of the viewport height and width. The body content could potentially\n   * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n   * added to the document body that sets overflow to hidden.\n   */\n  useEffect(function handleBodyScroll() {\n    if (isMobile && (isNavigationOpen || isToolsOpen)) {\n      document.body.classList.add(styles['block-body-scroll']);\n    } else {\n      document.body.classList.remove(styles['block-body-scroll']);\n    }\n    // Ensure the CSS class is removed from the body on side effect cleanup\n    return function cleanup() {\n      document.body.classList.remove(styles['block-body-scroll']);\n    };\n  }, [isMobile, isNavigationOpen, isToolsOpen]);\n  /**\n   * The useImperativeHandle hook in conjunction with the forwardRef function\n   * in the AppLayout component definition expose the following callable\n   * functions to component consumers when they put a ref as a property on\n   * their component implementation.\n   */\n  useImperativeHandle(forwardRef, function createImperativeHandle() {\n    return {\n      closeNavigationIfNecessary: function () {\n        isMobile && handleNavigationClick(false);\n      },\n      openTools: function () {\n        handleToolsClick(true);\n      },\n      focusToolsClose: toolsFocusControl.setFocus\n    };\n  }, [isMobile, handleNavigationClick, handleToolsClick, toolsFocusControl.setFocus]);\n  /**\n   * Query the DOM for the header and footer elements based on the selectors provided\n   * by the properties and pass the heights to the custom property definitions.\n   */\n  var _o = useState(0),\n    headerHeight = _o[0],\n    setHeaderHeight = _o[1];\n  var getHeader = useCallback(function () {\n    return document.querySelector(headerSelector);\n  }, [headerSelector]);\n  useResizeObserver(getHeader, function (entry) {\n    return setHeaderHeight(entry.borderBoxHeight);\n  });\n  var _p = useState(0),\n    footerHeight = _p[0],\n    setFooterHeight = _p[1];\n  var getFooter = useCallback(function () {\n    return document.querySelector(footerSelector);\n  }, [footerSelector]);\n  useResizeObserver(getFooter, function (entry) {\n    return setFooterHeight(entry.borderBoxHeight);\n  });\n  /**\n   * Set the default values for the minimum and maximum Split Panel width when it is\n   * in the side position. The useLayoutEffect will compute the available space in the\n   * DOM for the Split Panel given the current state. The minimum and maximum\n   * widths will potentially trigger a side effect that will put the Split Panel into\n   * a forced position on the bottom.\n   */\n  var splitPanelMinWidth = 280;\n  var _q = useState(splitPanelMinWidth),\n    splitPanelMaxWidth = _q[0],\n    setSplitPanelMaxWidth = _q[1];\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Split Panel. By default\n   * the Split Panel should always be closed on page load.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the click events that will change the state of the SplitPanel\n   * to open or closed given the current state. It will set the isSplitPanelOpen\n   * controlled state and fire the onSplitPanelToggle event.\n   */\n  var _r = useControllable(props.splitPanelOpen, props.onSplitPanelToggle, false, {\n      componentName: 'AppLayout',\n      controlledProp: 'splitPanelOpen',\n      changeHandler: 'onSplitPanelToggle'\n    }),\n    isSplitPanelOpen = _r[0],\n    setIsSplitPanelOpen = _r[1];\n  var handleSplitPanelClick = useCallback(function handleSplitPanelChange() {\n    setIsSplitPanelOpen(!isSplitPanelOpen);\n    fireNonCancelableEvent(props.onSplitPanelToggle, {\n      open: !isSplitPanelOpen\n    });\n  }, [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen]);\n  /**\n   * The useControllable hook will manage the controlled or uncontrolled\n   * state of the splitPanelPreferences. By default the splitPanelPreferences\n   * is undefined. When set the object shape should have a single key to indicate\n   * either bottom or side position.\n   *\n   * The callback that will handle changes to the splitPanelPreferences\n   * object that will determine if the SplitPanel is rendered either on the\n   * bottom of the viewport or within the Tools container.\n   */\n  var _s = useControllable(props.splitPanelPreferences, props.onSplitPanelPreferencesChange, undefined, {\n      componentName: 'AppLayout',\n      controlledProp: 'splitPanelPreferences',\n      changeHandler: 'onSplitPanelPreferencesChange'\n    }),\n    splitPanelPreferences = _s[0],\n    setSplitPanelPreferences = _s[1];\n  /**\n   * The Split Panel will be in forced (bottom) position if the defined minimum width is\n   * greater than the maximum width. In other words, the maximum width is the currently\n   * available horizontal space based on all other components that are rendered. If the\n   * minimum width exceeds this value then there is not enough horizontal space and we must\n   * force it to the bottom position.\n   */\n  var _t = useState(false),\n    isSplitPanelForcedPosition = _t[0],\n    setSplitPanelForcedPosition = _t[1];\n  var splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n  useLayoutEffect(function handleSplitPanelForcePosition() {\n    setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth);\n  }, [splitPanelMaxWidth, splitPanelMinWidth]);\n  /**\n   * The useControllable hook will set the default size of the SplitPanel based\n   * on the default position set in the splitPanelPreferences. The logic for the\n   * default size is contained in the SplitPanel component. The splitPanelControlledSize\n   * will be bound to the size property in the SplitPanel context for rendering.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the resize events that will change the size of the SplitPanel.\n   * It will set the splitPanelControlledSize controlled state and fire the\n   * onSplitPanelResize event.\n   */\n  var _u = useState(0),\n    splitPanelReportedSize = _u[0],\n    setSplitPanelReportedSize = _u[1];\n  var _v = useControllable(props.splitPanelSize, props.onSplitPanelResize, getSplitPanelDefaultSize(splitPanelPosition), {\n      componentName: 'AppLayout',\n      controlledProp: 'splitPanelSize',\n      changeHandler: 'onSplitPanelResize'\n    }),\n    splitPanelSize = _v[0],\n    setSplitPanelSize = _v[1];\n  var handleSplitPanelResize = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelSize(detail.size);\n    fireNonCancelableEvent(props.onSplitPanelResize, detail);\n  }, [props.onSplitPanelResize, setSplitPanelSize]);\n  var handleSplitPanelPreferencesChange = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelPreferences(detail);\n    fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n  }, [props.onSplitPanelPreferencesChange, setSplitPanelPreferences]);\n  /**\n   * The Layout element is not necessarily synonymous with the client\n   * viewport width. There can be content in the horizontal viewport\n   * that exists on either side of the AppLayout. This resize observer\n   * will set the custom property of the Layout element width that\n   * is used for various horizontal constraints such as the maximum\n   * allowed width of the Tools container.\n   *\n   * The offsetLeft of the Main will return the distance that the\n   * Main element has from the left edge of the Layout component.\n   * The offsetLeft value can vary based on the presence and state\n   * of the Navigation as well as content gaps in the grid definition.\n   * This value is used to determine the max width constraint calculation\n   * for the Tools container.\n   */\n  var _w = useContainerQuery(function (rect) {\n      return rect.width;\n    }),\n    layoutContainerQuery = _w[0],\n    layoutElement = _w[1];\n  var layoutWidth = layoutContainerQuery !== null && layoutContainerQuery !== void 0 ? layoutContainerQuery : 0;\n  var mainElement = useRef(null);\n  var _x = useState(0),\n    mainOffsetLeft = _x[0],\n    setMainOffsetLeft = _x[1];\n  useLayoutEffect(function handleMainOffsetLeft() {\n    var _a, _b;\n    setMainOffsetLeft((_b = (_a = mainElement === null || mainElement === void 0 ? void 0 : mainElement.current) === null || _a === void 0 ? void 0 : _a.offsetLeft) !== null && _b !== void 0 ? _b : 0);\n  }, [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize]);\n  useLayoutEffect(function handleSplitPanelMaxWidth() {\n    /**\n     * Warning! This is a hack! In order to accurately calculate if there is adequate\n     * horizontal space for the Split Panel to be in the side position we need two values\n     * that are not available in JavaScript.\n     *\n     * The first is the the content gap on the right which is stored in a design token\n     * and applied in the Layout CSS:\n     *\n     *  $contentGapRight: #{awsui.$space-scaled-2x-xxxl};\n     *\n     * The second is the width of the element that has the circular buttons for the\n     * Tools and Split Panel. This could be suppressed given the state of the Tools\n     * drawer returning a zero value. It would, however, be rendered if the Split Panel\n     * were to move into the side position. This is calculated in the Tools CSS and\n     * the Trigger button CSS with design tokens:\n     *\n     * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n     * width: awsui.$space-layout-toggle-diameter;\n     *\n     * These values will be defined below as static integers that are rough approximations\n     * of their computed width when rendered in the DOM, but doubled to ensure adequate\n     * spacing for the Split Panel to be in side position.\n     */\n    var contentGapRight = 80; // Approximately 40px when rendered but doubled for safety\n    var toolsFormOffsetWidth = 160; // Approximately 80px when rendered but doubled for safety\n    var toolsOffsetWidth = isToolsOpen ? toolsWidth : 0;\n    setSplitPanelMaxWidth(layoutWidth - mainOffsetLeft - minContentWidth - contentGapRight - toolsOffsetWidth - toolsFormOffsetWidth);\n  }, [isNavigationOpen, isToolsOpen, layoutWidth, mainOffsetLeft, minContentWidth, toolsWidth]);\n  /**\n   * Because the notifications slot does not give us any direction insight into\n   * what the state of the child content is we need to have a mechanism for\n   * tracking the height of the notifications and whether or not it has content.\n   * The height of the notifications is an integer that will be used as a custom\n   * property on the Layout component to determine what the sticky offset should\n   * be if there are sticky notifications. This could be any number including\n   * zero based on how the child content renders. The hasNotificationsContent boolean\n   * is simply centralizing the logic of the notifications height being > 0 such\n   * that it is not repeated in various components (such as AppBar) that need to\n   * know if the notifications slot is empty.\n   */\n  var _y = useContainerQuery(function (rect) {\n      return rect.height;\n    }),\n    notificationsContainerQuery = _y[0],\n    notificationsElement = _y[1];\n  var _z = useState(0),\n    notificationsHeight = _z[0],\n    setNotificationsHeight = _z[1];\n  var _0 = useState(false),\n    hasNotificationsContent = _0[0],\n    setHasNotificationsContent = _0[1];\n  useEffect(function handleNotificationsContent() {\n    setNotificationsHeight(notificationsContainerQuery !== null && notificationsContainerQuery !== void 0 ? notificationsContainerQuery : 0);\n    setHasNotificationsContent(notificationsContainerQuery && notificationsContainerQuery > 0 ? true : false);\n  }, [notificationsContainerQuery]);\n  /**\n   * The offsetBottom value is used to determine the distance from the bottom of the\n   * viewport a sticky element should be placed. A non-zero value means that there\n   * is either a footer outside of the AppLayout, a SplitPanel in the bottom position\n   * within the AppLayout, or both.\n   */\n  var _1 = useState(0),\n    offsetBottom = _1[0],\n    setOffsetBottom = _1[1];\n  return React.createElement(AppLayoutContext.Provider, {\n    value: __assign(__assign(__assign({}, defaults), props), {\n      contentType: contentType,\n      dynamicOverlapHeight: dynamicOverlapHeight,\n      headerHeight: headerHeight,\n      footerHeight: footerHeight,\n      hasDefaultToolsWidth: hasDefaultToolsWidth,\n      handleNavigationClick: handleNavigationClick,\n      handleSplitPanelClick: handleSplitPanelClick,\n      handleSplitPanelPreferencesChange: handleSplitPanelPreferencesChange,\n      handleSplitPanelResize: handleSplitPanelResize,\n      handleToolsClick: handleToolsClick,\n      hasNotificationsContent: hasNotificationsContent,\n      isAnyPanelOpen: isAnyPanelOpen,\n      isMobile: isMobile,\n      isNavigationOpen: isNavigationOpen !== null && isNavigationOpen !== void 0 ? isNavigationOpen : false,\n      isSplitPanelForcedPosition: isSplitPanelForcedPosition,\n      isSplitPanelOpen: isSplitPanelOpen,\n      isToolsOpen: isToolsOpen,\n      layoutElement: layoutElement,\n      layoutWidth: layoutWidth,\n      mainElement: mainElement,\n      mainOffsetLeft: mainOffsetLeft,\n      maxContentWidth: maxContentWidth,\n      minContentWidth: minContentWidth,\n      navigationHide: navigationHide,\n      notificationsElement: notificationsElement,\n      notificationsHeight: notificationsHeight,\n      offsetBottom: offsetBottom,\n      setDynamicOverlapHeight: setDynamicOverlapHeight,\n      setOffsetBottom: setOffsetBottom,\n      setSplitPanelReportedSize: setSplitPanelReportedSize,\n      splitPanelMaxWidth: splitPanelMaxWidth,\n      splitPanelMinWidth: splitPanelMinWidth,\n      splitPanelPosition: splitPanelPosition,\n      splitPanelPreferences: splitPanelPreferences,\n      splitPanelReportedSize: splitPanelReportedSize,\n      splitPanelSize: splitPanelSize,\n      toolsHide: toolsHide,\n      toolsOpen: isToolsOpen,\n      toolsWidth: toolsWidth,\n      toolsFocusControl: toolsFocusControl\n    })\n  }, children);\n});","map":{"version":3,"mappings":"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","names":["React","createContext","createRef","useCallback","useEffect","useLayoutEffect","useImperativeHandle","useRef","useState","fireNonCancelableEvent","getSplitPanelPosition","useControllable","useMobile","useContainerQuery","useResizeObserver","getSplitPanelDefaultSize","styles","isDevelopment","warnOnce","applyDefaults","useFocusControl","defaults","breadcrumbs","content","contentHeader","contentType","disableBodyScroll","disableContentHeaderOverlap","disableContentPaddings","dynamicOverlapHeight","headerHeight","footerHeight","handleNavigationClick","value","handleSplitPanelClick","handleSplitPanelPreferencesChange","handleSplitPanelResize","handleToolsClick","hasDefaultToolsWidth","hasNotificationsContent","isAnyPanelOpen","isMobile","isNavigationOpen","isSplitPanelForcedPosition","isSplitPanelOpen","isToolsOpen","layoutElement","layoutWidth","mainElement","mainOffsetLeft","maxContentWidth","minContentWidth","navigation","navigationHide","navigationOpen","notifications","notificationsElement","notificationsHeight","offsetBottom","onNavigationChange","onSplitPanelResize","onSplitPanelToggle","onSplitPanelPreferencesChange","setDynamicOverlapHeight","setIsNavigationOpen","setIsToolsOpen","setOffsetBottom","setSplitPanelReportedSize","splitPanelMaxWidth","splitPanelMinWidth","splitPanelOpen","splitPanelPosition","splitPanelPreferences","position","splitPanelReportedSize","splitPanelSize","stickyNotifications","tools","toolsFocusControl","AppLayoutContext","AppLayoutProvider","forwardRef","_a","controlledToolsOpen","controlledNavigationOpen","_e","_f","headerSelector","_g","footerSelector","children","props","toolsHide","geckoMaxCssLength","halfGeckoMaxCssLength","contentTypeDefaults","componentName","controlledProp","changeHandler","_k","handleNavigationChange","isOpen","open","toolsWidth","undefined","onToolsChange","toolsOpen","_m","handleToolsChange","navigationVisible","toolsVisible","handleBodyScroll","document","body","classList","add","remove","cleanup","createImperativeHandle","closeNavigationIfNecessary","openTools","focusToolsClose","setFocus","setHeaderHeight","getHeader","querySelector","entry","borderBoxHeight","setFooterHeight","getFooter","setSplitPanelMaxWidth","setIsSplitPanelOpen","handleSplitPanelChange","setSplitPanelPreferences","setSplitPanelForcedPosition","handleSplitPanelForcePosition","setSplitPanelSize","detail","size","width","layoutContainerQuery","setMainOffsetLeft","handleMainOffsetLeft","current","offsetLeft","handleSplitPanelMaxWidth","contentGapRight","toolsFormOffsetWidth","toolsOffsetWidth","height","notificationsContainerQuery","setNotificationsHeight","setHasNotificationsContent","handleNotificationsContent","Provider"],"sources":["/Users/dcastro/node_modules/src/app-layout/visual-refresh/context.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, {\n  createContext,\n  createRef,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport { AppLayoutProps } from '../interfaces';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { getSplitPanelPosition } from './split-panel';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useContainerQuery, useResizeObserver } from '../../internal/hooks/container-queries';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../../internal/is-development';\nimport { warnOnce } from '../../internal/logging';\nimport { applyDefaults } from '../defaults';\nimport { FocusControlState, useFocusControl } from '../utils/use-focus-control';\n\ninterface AppLayoutContextProps extends AppLayoutProps {\n  dynamicOverlapHeight: number;\n  handleSplitPanelClick: () => void;\n  handleNavigationClick: (isOpen: boolean) => void;\n  handleSplitPanelPreferencesChange: (detail: AppLayoutProps.SplitPanelPreferences) => void;\n  handleSplitPanelResize: (detail: { size: number }) => void;\n  handleToolsClick: (value: boolean) => void;\n  hasDefaultToolsWidth: boolean;\n  hasNotificationsContent: boolean;\n  isAnyPanelOpen: boolean;\n  isMobile: boolean;\n  isNavigationOpen: boolean;\n  isSplitPanelForcedPosition: boolean;\n  isSplitPanelOpen?: boolean;\n  isToolsOpen: boolean;\n  layoutElement: React.Ref<HTMLElement>;\n  layoutWidth: number;\n  mainElement: React.Ref<HTMLDivElement>;\n  mainOffsetLeft: number;\n  notificationsElement: React.Ref<HTMLDivElement>;\n  notificationsHeight: number;\n  offsetBottom: number;\n  setDynamicOverlapHeight: (value: number) => void;\n  setIsNavigationOpen: (value: boolean) => void;\n  setIsToolsOpen: (value: boolean) => void;\n  setOffsetBottom: (value: number) => void;\n  setSplitPanelReportedSize: (value: number) => void;\n  headerHeight: number;\n  footerHeight: number;\n  splitPanelMaxWidth: number;\n  splitPanelMinWidth: number;\n  splitPanelPosition: AppLayoutProps.SplitPanelPosition;\n  splitPanelReportedSize: number;\n  toolsFocusControl: FocusControlState;\n}\n\n// TODO simplify default params + typings\nconst defaults: AppLayoutContextProps = {\n  breadcrumbs: null,\n  content: null,\n  contentHeader: null,\n  contentType: 'default',\n  disableBodyScroll: false,\n  disableContentHeaderOverlap: false,\n  disableContentPaddings: false,\n  dynamicOverlapHeight: 0,\n  headerHeight: 0,\n  footerHeight: 0,\n  handleNavigationClick: (value: boolean) => value,\n  handleSplitPanelClick: () => {},\n  handleSplitPanelPreferencesChange: () => {},\n  handleSplitPanelResize: () => {},\n  handleToolsClick: (value: boolean) => value,\n  hasDefaultToolsWidth: true,\n  hasNotificationsContent: false,\n  isAnyPanelOpen: false,\n  isMobile: false,\n  isNavigationOpen: false,\n  isSplitPanelForcedPosition: false,\n  isSplitPanelOpen: false,\n  isToolsOpen: false,\n  // TODO: these refs are currently only instantiated once globally\n  layoutElement: createRef<HTMLElement>(),\n  layoutWidth: 0,\n  mainElement: createRef<HTMLDivElement>(),\n  mainOffsetLeft: 0,\n  maxContentWidth: 0,\n  minContentWidth: 280,\n  navigation: null,\n  navigationHide: false,\n  navigationOpen: false,\n  notifications: null,\n  notificationsElement: createRef<HTMLDivElement>(),\n  notificationsHeight: 0,\n  offsetBottom: 0,\n  onNavigationChange: () => {},\n  onSplitPanelResize: () => {},\n  onSplitPanelToggle: () => {},\n  onSplitPanelPreferencesChange: () => {},\n  setDynamicOverlapHeight: (value: number) => void value,\n  setIsNavigationOpen: (value: boolean) => value,\n  setIsToolsOpen: (value: boolean) => value,\n  setOffsetBottom: (value: number) => void value,\n  setSplitPanelReportedSize: (value: number) => void value,\n  splitPanelMaxWidth: 280,\n  splitPanelMinWidth: 280,\n  splitPanelOpen: false,\n  splitPanelPosition: 'bottom',\n  splitPanelPreferences: { position: 'bottom' },\n  splitPanelReportedSize: 0,\n  splitPanelSize: 0,\n  stickyNotifications: false,\n  tools: null,\n  toolsFocusControl: {} as FocusControlState,\n};\n\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\nexport const AppLayoutContext = createContext({ ...defaults });\n\ntype AppLayoutProviderProps = AppLayoutProps & {\n  children: React.ReactNode;\n};\n\nexport const AppLayoutProvider = React.forwardRef(\n  (\n    {\n      toolsHide,\n      toolsOpen: controlledToolsOpen,\n      navigationHide,\n      navigationOpen: controlledNavigationOpen,\n      contentType = 'default',\n      headerSelector = '#b #h',\n      footerSelector = '#b #h',\n      children,\n      ...props\n    }: AppLayoutProviderProps,\n    forwardRef: React.Ref<AppLayoutProps.Ref>\n  ) => {\n    const isMobile = useMobile();\n\n    if (isDevelopment) {\n      if (controlledToolsOpen && toolsHide) {\n        warnOnce(\n          'AppLayout',\n          `You have enabled both the \\`toolsOpen\\` prop and the \\`toolsHide\\` prop. This is not supported. Set \\`toolsOpen\\` to \\`false\\` when you set \\`toolsHide\\` to \\`true\\`.`\n        );\n      }\n    }\n\n    /**\n     * The overlap height has a default set in CSS but can also be dynamically overridden\n     * for content types (such as Table and Wizard) that have variable size content in the overlap.\n     */\n    const [dynamicOverlapHeight, setDynamicOverlapHeight] = useState(0);\n\n    /**\n     * Set the default values for minimum and maximum content width.\n     */\n    const geckoMaxCssLength = ((1 << 30) - 1) / 60;\n    const halfGeckoMaxCssLength = geckoMaxCssLength / 2;\n    // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n    // Limit the maxContentWidth to the half of the upper boundary (≈4230^2) to be on the safe side.\n    const maxContentWidth =\n      props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength\n        ? halfGeckoMaxCssLength\n        : props.maxContentWidth ?? 0;\n    const minContentWidth = props.minContentWidth ?? 280;\n\n    /**\n     * Determine the default state of the Navigation and Tools drawers.\n     * Mobile viewports should be closed by default under all circumstances.\n     * If the navigationOpen prop has been set then that should take precedence\n     * over the contentType prop. Desktop viewports that do not have the\n     * navigationOpen or contentType props set will use the default contentType.\n     */\n    const contentTypeDefaults = applyDefaults(contentType, { maxContentWidth, minContentWidth }, true);\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Navigation drawer. The logic\n     * for determining the default state is colocated with the Navigation component.\n     *\n     * The callback that will be passed to the Navigation and AppBar\n     * components to handle the click events that will change the state\n     * of the Navigation drawer. It will set the Navigation state with the\n     * useControllable hook and also fire the onNavigationChange function to\n     * emit the state change.\n     */\n    const [isNavigationOpen = false, setIsNavigationOpen] = useControllable(\n      controlledNavigationOpen,\n      props.onNavigationChange,\n      isMobile ? false : contentTypeDefaults.navigationOpen,\n      { componentName: 'AppLayout', controlledProp: 'navigationOpen', changeHandler: 'onNavigationChange' }\n    );\n\n    const handleNavigationClick = useCallback(\n      function handleNavigationChange(isOpen: boolean) {\n        setIsNavigationOpen(isOpen);\n        fireNonCancelableEvent(props.onNavigationChange, { open: isOpen });\n      },\n      [props.onNavigationChange, setIsNavigationOpen]\n    );\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Tools drawer. The logic\n     * for determining the default state is colocated with the Tools component.\n     *\n     * The callback that will be passed to the Navigation and AppBar\n     * components to handle the click events that will change the state\n     * of the Tools drawer. It will set the Tools state with the\n     * useControllable hook and also fire the onToolsChange function to\n     * emit the state change.\n     */\n    const toolsWidth = props.toolsWidth ?? 290;\n    const hasDefaultToolsWidth = props.toolsWidth === undefined;\n\n    const [isToolsOpen = false, setIsToolsOpen] = useControllable(\n      controlledToolsOpen,\n      props.onToolsChange,\n      isMobile ? false : contentTypeDefaults.toolsOpen,\n      { componentName: 'AppLayout', controlledProp: 'toolsOpen', changeHandler: 'onToolsChange' }\n    );\n\n    const toolsFocusControl = useFocusControl(isToolsOpen, true);\n\n    const handleToolsClick = useCallback(\n      function handleToolsChange(isOpen: boolean) {\n        setIsToolsOpen(isOpen);\n        fireNonCancelableEvent(props.onToolsChange, { open: isOpen });\n      },\n      [props.onToolsChange, setIsToolsOpen]\n    );\n\n    const navigationVisible = !navigationHide && isNavigationOpen;\n    const toolsVisible = !toolsHide && isToolsOpen;\n    const isAnyPanelOpen = navigationVisible || toolsVisible;\n\n    /**\n     * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n     * that consumes 100% of the viewport height and width. The body content could potentially\n     * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n     * added to the document body that sets overflow to hidden.\n     */\n    useEffect(\n      function handleBodyScroll() {\n        if (isMobile && (isNavigationOpen || isToolsOpen)) {\n          document.body.classList.add(styles['block-body-scroll']);\n        } else {\n          document.body.classList.remove(styles['block-body-scroll']);\n        }\n\n        // Ensure the CSS class is removed from the body on side effect cleanup\n        return function cleanup() {\n          document.body.classList.remove(styles['block-body-scroll']);\n        };\n      },\n      [isMobile, isNavigationOpen, isToolsOpen]\n    );\n\n    /**\n     * The useImperativeHandle hook in conjunction with the forwardRef function\n     * in the AppLayout component definition expose the following callable\n     * functions to component consumers when they put a ref as a property on\n     * their component implementation.\n     */\n    useImperativeHandle(\n      forwardRef,\n      function createImperativeHandle() {\n        return {\n          closeNavigationIfNecessary: function () {\n            isMobile && handleNavigationClick(false);\n          },\n          openTools: function () {\n            handleToolsClick(true);\n          },\n          focusToolsClose: toolsFocusControl.setFocus,\n        };\n      },\n      [isMobile, handleNavigationClick, handleToolsClick, toolsFocusControl.setFocus]\n    );\n\n    /**\n     * Query the DOM for the header and footer elements based on the selectors provided\n     * by the properties and pass the heights to the custom property definitions.\n     */\n    const [headerHeight, setHeaderHeight] = useState(0);\n    const getHeader = useCallback(() => document.querySelector(headerSelector), [headerSelector]);\n    useResizeObserver(getHeader, entry => setHeaderHeight(entry.borderBoxHeight));\n\n    const [footerHeight, setFooterHeight] = useState(0);\n    const getFooter = useCallback(() => document.querySelector(footerSelector), [footerSelector]);\n    useResizeObserver(getFooter, entry => setFooterHeight(entry.borderBoxHeight));\n\n    /**\n     * Set the default values for the minimum and maximum Split Panel width when it is\n     * in the side position. The useLayoutEffect will compute the available space in the\n     * DOM for the Split Panel given the current state. The minimum and maximum\n     * widths will potentially trigger a side effect that will put the Split Panel into\n     * a forced position on the bottom.\n     */\n    const splitPanelMinWidth = 280;\n    const [splitPanelMaxWidth, setSplitPanelMaxWidth] = useState(splitPanelMinWidth);\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Split Panel. By default\n     * the Split Panel should always be closed on page load.\n     *\n     * The callback that will be passed to the SplitPanel component\n     * to handle the click events that will change the state of the SplitPanel\n     * to open or closed given the current state. It will set the isSplitPanelOpen\n     * controlled state and fire the onSplitPanelToggle event.\n     */\n    const [isSplitPanelOpen, setIsSplitPanelOpen] = useControllable(\n      props.splitPanelOpen,\n      props.onSplitPanelToggle,\n      false,\n      { componentName: 'AppLayout', controlledProp: 'splitPanelOpen', changeHandler: 'onSplitPanelToggle' }\n    );\n\n    const handleSplitPanelClick = useCallback(\n      function handleSplitPanelChange() {\n        setIsSplitPanelOpen(!isSplitPanelOpen);\n        fireNonCancelableEvent(props.onSplitPanelToggle, { open: !isSplitPanelOpen });\n      },\n      [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen]\n    );\n\n    /**\n     * The useControllable hook will manage the controlled or uncontrolled\n     * state of the splitPanelPreferences. By default the splitPanelPreferences\n     * is undefined. When set the object shape should have a single key to indicate\n     * either bottom or side position.\n     *\n     * The callback that will handle changes to the splitPanelPreferences\n     * object that will determine if the SplitPanel is rendered either on the\n     * bottom of the viewport or within the Tools container.\n     */\n    const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(\n      props.splitPanelPreferences,\n      props.onSplitPanelPreferencesChange,\n      undefined,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelPreferences',\n        changeHandler: 'onSplitPanelPreferencesChange',\n      }\n    );\n\n    /**\n     * The Split Panel will be in forced (bottom) position if the defined minimum width is\n     * greater than the maximum width. In other words, the maximum width is the currently\n     * available horizontal space based on all other components that are rendered. If the\n     * minimum width exceeds this value then there is not enough horizontal space and we must\n     * force it to the bottom position.\n     */\n    const [isSplitPanelForcedPosition, setSplitPanelForcedPosition] = useState(false);\n    const splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n\n    useLayoutEffect(\n      function handleSplitPanelForcePosition() {\n        setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth);\n      },\n      [splitPanelMaxWidth, splitPanelMinWidth]\n    );\n\n    /**\n     * The useControllable hook will set the default size of the SplitPanel based\n     * on the default position set in the splitPanelPreferences. The logic for the\n     * default size is contained in the SplitPanel component. The splitPanelControlledSize\n     * will be bound to the size property in the SplitPanel context for rendering.\n     *\n     * The callback that will be passed to the SplitPanel component\n     * to handle the resize events that will change the size of the SplitPanel.\n     * It will set the splitPanelControlledSize controlled state and fire the\n     * onSplitPanelResize event.\n     */\n    const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n\n    const [splitPanelSize, setSplitPanelSize] = useControllable(\n      props.splitPanelSize,\n      props.onSplitPanelResize,\n      getSplitPanelDefaultSize(splitPanelPosition),\n      { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' }\n    );\n\n    const handleSplitPanelResize = useCallback(\n      function handleSplitPanelChange(detail: { size: number }) {\n        setSplitPanelSize(detail.size);\n        fireNonCancelableEvent(props.onSplitPanelResize, detail);\n      },\n      [props.onSplitPanelResize, setSplitPanelSize]\n    );\n\n    const handleSplitPanelPreferencesChange = useCallback(\n      function handleSplitPanelChange(detail: AppLayoutProps.SplitPanelPreferences) {\n        setSplitPanelPreferences(detail);\n        fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n      },\n      [props.onSplitPanelPreferencesChange, setSplitPanelPreferences]\n    );\n\n    /**\n     * The Layout element is not necessarily synonymous with the client\n     * viewport width. There can be content in the horizontal viewport\n     * that exists on either side of the AppLayout. This resize observer\n     * will set the custom property of the Layout element width that\n     * is used for various horizontal constraints such as the maximum\n     * allowed width of the Tools container.\n     *\n     * The offsetLeft of the Main will return the distance that the\n     * Main element has from the left edge of the Layout component.\n     * The offsetLeft value can vary based on the presence and state\n     * of the Navigation as well as content gaps in the grid definition.\n     * This value is used to determine the max width constraint calculation\n     * for the Tools container.\n     */\n    const [layoutContainerQuery, layoutElement] = useContainerQuery(rect => rect.width);\n    const layoutWidth = layoutContainerQuery ?? 0;\n\n    const mainElement = useRef<HTMLDivElement>(null);\n    const [mainOffsetLeft, setMainOffsetLeft] = useState(0);\n\n    useLayoutEffect(\n      function handleMainOffsetLeft() {\n        setMainOffsetLeft(mainElement?.current?.offsetLeft ?? 0);\n      },\n      [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize]\n    );\n\n    useLayoutEffect(\n      function handleSplitPanelMaxWidth() {\n        /**\n         * Warning! This is a hack! In order to accurately calculate if there is adequate\n         * horizontal space for the Split Panel to be in the side position we need two values\n         * that are not available in JavaScript.\n         *\n         * The first is the the content gap on the right which is stored in a design token\n         * and applied in the Layout CSS:\n         *\n         *  $contentGapRight: #{awsui.$space-scaled-2x-xxxl};\n         *\n         * The second is the width of the element that has the circular buttons for the\n         * Tools and Split Panel. This could be suppressed given the state of the Tools\n         * drawer returning a zero value. It would, however, be rendered if the Split Panel\n         * were to move into the side position. This is calculated in the Tools CSS and\n         * the Trigger button CSS with design tokens:\n         *\n         * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n         * width: awsui.$space-layout-toggle-diameter;\n         *\n         * These values will be defined below as static integers that are rough approximations\n         * of their computed width when rendered in the DOM, but doubled to ensure adequate\n         * spacing for the Split Panel to be in side position.\n         */\n        const contentGapRight = 80; // Approximately 40px when rendered but doubled for safety\n        const toolsFormOffsetWidth = 160; // Approximately 80px when rendered but doubled for safety\n        const toolsOffsetWidth = isToolsOpen ? toolsWidth : 0;\n\n        setSplitPanelMaxWidth(\n          layoutWidth - mainOffsetLeft - minContentWidth - contentGapRight - toolsOffsetWidth - toolsFormOffsetWidth\n        );\n      },\n      [isNavigationOpen, isToolsOpen, layoutWidth, mainOffsetLeft, minContentWidth, toolsWidth]\n    );\n\n    /**\n     * Because the notifications slot does not give us any direction insight into\n     * what the state of the child content is we need to have a mechanism for\n     * tracking the height of the notifications and whether or not it has content.\n     * The height of the notifications is an integer that will be used as a custom\n     * property on the Layout component to determine what the sticky offset should\n     * be if there are sticky notifications. This could be any number including\n     * zero based on how the child content renders. The hasNotificationsContent boolean\n     * is simply centralizing the logic of the notifications height being > 0 such\n     * that it is not repeated in various components (such as AppBar) that need to\n     * know if the notifications slot is empty.\n     */\n    const [notificationsContainerQuery, notificationsElement] = useContainerQuery(rect => rect.height);\n    const [notificationsHeight, setNotificationsHeight] = useState(0);\n    const [hasNotificationsContent, setHasNotificationsContent] = useState(false);\n\n    useEffect(\n      function handleNotificationsContent() {\n        setNotificationsHeight(notificationsContainerQuery ?? 0);\n        setHasNotificationsContent(notificationsContainerQuery && notificationsContainerQuery > 0 ? true : false);\n      },\n      [notificationsContainerQuery]\n    );\n\n    /**\n     * The offsetBottom value is used to determine the distance from the bottom of the\n     * viewport a sticky element should be placed. A non-zero value means that there\n     * is either a footer outside of the AppLayout, a SplitPanel in the bottom position\n     * within the AppLayout, or both.\n     */\n    const [offsetBottom, setOffsetBottom] = useState(0);\n\n    return (\n      <AppLayoutContext.Provider\n        value={{\n          ...defaults,\n          ...props,\n          contentType,\n          dynamicOverlapHeight,\n          headerHeight,\n          footerHeight,\n          hasDefaultToolsWidth,\n          handleNavigationClick,\n          handleSplitPanelClick,\n          handleSplitPanelPreferencesChange,\n          handleSplitPanelResize,\n          handleToolsClick,\n          hasNotificationsContent,\n          isAnyPanelOpen,\n          isMobile,\n          isNavigationOpen: isNavigationOpen ?? false,\n          isSplitPanelForcedPosition,\n          isSplitPanelOpen,\n          isToolsOpen,\n          layoutElement,\n          layoutWidth,\n          mainElement,\n          mainOffsetLeft,\n          maxContentWidth,\n          minContentWidth,\n          navigationHide,\n          notificationsElement,\n          notificationsHeight,\n          offsetBottom,\n          setDynamicOverlapHeight,\n          setOffsetBottom,\n          setSplitPanelReportedSize,\n          splitPanelMaxWidth,\n          splitPanelMinWidth,\n          splitPanelPosition,\n          splitPanelPreferences,\n          splitPanelReportedSize,\n          splitPanelSize,\n          toolsHide,\n          toolsOpen: isToolsOpen,\n          toolsWidth,\n          toolsFocusControl,\n        }}\n      >\n        {children}\n      </AppLayoutContext.Provider>\n    );\n  }\n);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}