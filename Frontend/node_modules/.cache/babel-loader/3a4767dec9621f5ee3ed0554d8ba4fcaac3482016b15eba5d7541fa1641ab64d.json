{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(filteringProperties, filteringText) {\n  filteringText = filteringText.toLowerCase();\n  var maxLength = 0;\n  var matchedProperty = null;\n  for (var _i = 0, filteringProperties_1 = filteringProperties; _i < filteringProperties_1.length; _i++) {\n    var property = filteringProperties_1[_i];\n    if (property.propertyLabel.length > maxLength && startsWith(filteringText, property.propertyLabel.toLowerCase())) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n  return matchedProperty;\n}\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(allowedOperators, filteringText) {\n  filteringText = filteringText.toLowerCase();\n  var maxLength = 0;\n  var matchedOperator = null;\n  for (var _i = 0, allowedOperators_1 = allowedOperators; _i < allowedOperators_1.length; _i++) {\n    var operator = allowedOperators_1[_i];\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n  return matchedOperator;\n}\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(allowedOperators, filteringText) {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (var _i = 0, allowedOperators_2 = allowedOperators; _i < allowedOperators_2.length; _i++) {\n    var operator = allowedOperators_2[_i];\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\nexport function trimStart(source) {\n  var spacesLength = 0;\n  for (var i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\nexport function trimFirstSpace(source) {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\nfunction startsWith(source, target) {\n  return source.indexOf(target) === 0;\n}","map":{"version":3,"mappings":"AAAA;AACA;AAIA;AACA,OAAM,SAAUA,sBAAsB,CACpCC,mBAAiD,EACjDC,aAAqB;EAErBA,aAAa,GAAGA,aAAa,CAACC,WAAW,EAAE;EAE3C,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,eAAe,GAA6B,IAAI;EAEpD,KAAuB,UAAmB,EAAnBC,2CAAmB,EAAnBC,iCAAmB,EAAnBA,IAAmB,EAAE;IAAvC,IAAMC,QAAQ;IACjB,IAAIA,QAAQ,CAACC,aAAa,CAACC,MAAM,GAAGN,SAAS,IAAIO,UAAU,CAACT,aAAa,EAAEM,QAAQ,CAACC,aAAa,CAACN,WAAW,EAAE,CAAC,EAAE;MAChHC,SAAS,GAAGI,QAAQ,CAACC,aAAa,CAACC,MAAM;MACzCL,eAAe,GAAGG,QAAQ;;;EAI9B,OAAOH,eAAe;AACxB;AAEA;AACA,OAAM,SAAUO,aAAa,CAC3BC,gBAA+C,EAC/CX,aAAqB;EAErBA,aAAa,GAAGA,aAAa,CAACC,WAAW,EAAE;EAE3C,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIU,eAAe,GAA8B,IAAI;EAErD,KAAuB,UAAgB,EAAhBC,qCAAgB,EAAhBR,8BAAgB,EAAhBA,IAAgB,EAAE;IAApC,IAAMS,QAAQ;IACjB,IAAIA,QAAQ,CAACN,MAAM,GAAGN,SAAS,IAAIO,UAAU,CAACT,aAAa,EAAEc,QAAQ,CAACb,WAAW,EAAE,CAAC,EAAE;MACpFC,SAAS,GAAGY,QAAQ,CAACN,MAAM;MAC3BI,eAAe,GAAGE,QAAQ;;;EAI9B,OAAOF,eAAe;AACxB;AAEA;AACA,OAAM,SAAUG,mBAAmB,CACjCJ,gBAA+C,EAC/CX,aAAqB;EAErB,IAAIA,aAAa,CAACgB,IAAI,EAAE,CAACR,MAAM,KAAK,CAAC,EAAE;IACrC,OAAO,EAAE;;EAEX,KAAuB,UAAgB,EAAhBS,qCAAgB,EAAhBZ,8BAAgB,EAAhBA,IAAgB,EAAE;IAApC,IAAMS,QAAQ;IACjB,IAAIL,UAAU,CAACK,QAAQ,CAACb,WAAW,EAAE,EAAED,aAAa,CAACC,WAAW,EAAE,CAAC,EAAE;MACnE,OAAOD,aAAa;;;EAGxB,OAAO,IAAI;AACb;AAEA,OAAM,SAAUkB,SAAS,CAACC,MAAc;EACtC,IAAIC,YAAY,GAAG,CAAC;EACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACX,MAAM,EAAEa,CAAC,EAAE,EAAE;IACtC,IAAIF,MAAM,CAACE,CAAC,CAAC,KAAK,GAAG,EAAE;MACrBD,YAAY,EAAE;KACf,MAAM;MACL;;;EAGJ,OAAOD,MAAM,CAACG,KAAK,CAACF,YAAY,CAAC;AACnC;AAEA,OAAM,SAAUG,cAAc,CAACJ,MAAc;EAC3C,OAAOA,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,GAAGA,MAAM,CAACG,KAAK,CAAC,CAAC,CAAC,GAAGH,MAAM;AACrD;AAEA,SAASV,UAAU,CAACU,MAAc,EAAEK,MAAc;EAChD,OAAOL,MAAM,CAACM,OAAO,CAACD,MAAM,CAAC,KAAK,CAAC;AACrC","names":["matchFilteringProperty","filteringProperties","filteringText","toLowerCase","maxLength","matchedProperty","filteringProperties_1","_i","property","propertyLabel","length","startsWith","matchOperator","allowedOperators","matchedOperator","allowedOperators_1","operator","matchOperatorPrefix","trim","allowedOperators_2","trimStart","source","spacesLength","i","slice","trimFirstSpace","target","indexOf"],"sources":["/Users/dcastro/node_modules/src/property-filter/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ComparisonOperator, FilteringProperty } from './interfaces';\n\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(\n  filteringProperties: readonly FilteringProperty[],\n  filteringText: string\n): null | FilteringProperty {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedProperty: null | FilteringProperty = null;\n\n  for (const property of filteringProperties) {\n    if (property.propertyLabel.length > maxLength && startsWith(filteringText, property.propertyLabel.toLowerCase())) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n\n  return matchedProperty;\n}\n\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | ComparisonOperator {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedOperator: null | ComparisonOperator = null;\n\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n\n  return matchedOperator;\n}\n\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | string {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\n\nexport function trimStart(source: string): string {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\n\nexport function trimFirstSpace(source: string): string {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\n\nfunction startsWith(source: string, target: string): boolean {\n  return source.indexOf(target) === 0;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}