{"ast":null,"code":"// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nvar EPSILON = 0.0000000000001;\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX(series) {\n  var xValues = getXValues(series);\n  if (xValues.length === 0) {\n    return [];\n  }\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues);\n  }\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(function (_a, x) {\n    var min = _a[0],\n      max = _a[1];\n    return [x < min ? x : min, max < x ? x : max];\n  }, [xValues[0], xValues[0]]);\n}\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY(series, scaleType) {\n  var min = Number.POSITIVE_INFINITY;\n  var max = Number.NEGATIVE_INFINITY;\n  // Find the min and max for threshold series.\n  series.forEach(function (s) {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach(function (_, xIndex) {\n    var _a;\n    // Maintains the prev stack level.\n    var stackY = scaleType === 'linear' ? 0 : EPSILON;\n    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n      var s = series_1[_i];\n      if (s.type === 'area') {\n        stackY = stackY + (((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n  return [min, max];\n}\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints(series, xScale, yScale) {\n  var xValues = getXValues(series);\n  // Lookup for xy[xIndex][yIndex]\n  var xy = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  var xs = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  var sx = [];\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(function (_a, xIndex) {\n    var x = _a.x,\n      scaledX = _a.scaledX;\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    var stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n    // A column of series points related to the same x.\n    var points = [];\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach(function (s, sIndex) {\n      var _a;\n      if (s.type === 'threshold') {\n        var scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: {\n            x: scaledX,\n            y0: scaledY,\n            y1: scaledY\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: 0\n        });\n      } else {\n        var value = ((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0;\n        var y0 = stackY;\n        var y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: {\n            x: scaledX,\n            y0: yScale.d3Scale(y0) || 0,\n            y1: yScale.d3Scale(y1) || 0\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: value\n        });\n        stackY = y1;\n      }\n    });\n    // Sort points by y and insert the missing y-index.\n    points.sort(function (p1, p2) {\n      return p1.y1 - p2.y1;\n    }).forEach(function (point, index) {\n      point.index.y = index;\n      // Insert the points to the respective two-dimensional lookup arrays.\n      insertIntoMatrix(xy, point.index.x, point.index.y, point);\n      insertIntoMatrix(xs, point.index.x, point.index.s, point);\n      insertIntoMatrix(sx, point.index.s, point.index.x, point);\n    });\n  });\n  return {\n    xy: xy,\n    xs: xs,\n    sx: sx\n  };\n}\n// Finds the closest point in the sorted array.\nexport function findClosest(sortedArray, target, getter) {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n  var isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  var compare = function (x) {\n    return isAscending ? getter(x) < target : getter(x) > target;\n  };\n  var delta = function (x) {\n    return Math.abs(getter(x) - target);\n  };\n  // Use binary search to find the closest value in a sorted array.\n  var lo = 0;\n  var hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    var mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index, _a) {\n  var from = _a[0],\n    to = _a[1];\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n// Delays function execution\nexport function throttle(func, delay) {\n  var pending = null;\n  var lastInvokeTime = null;\n  var timerId = null;\n  // Runs on every animation frame until timer stopped.\n  function pendingFunc() {\n    if (pending && lastInvokeTime !== null) {\n      var time = Date.now();\n      var shouldInvoke = time - lastInvokeTime >= delay;\n      if (shouldInvoke) {\n        func.apply(pending[\"this\"], pending.args);\n        lastInvokeTime = time;\n        pending = null;\n      } else {\n        startTimer();\n      }\n    }\n  }\n  function startTimer() {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    timerId = requestAnimationFrame(pendingFunc);\n  }\n  // Decorated client function with delay mechanism.\n  function throttled() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (lastInvokeTime === null) {\n      func.apply(this, args);\n      lastInvokeTime = Date.now();\n    } else {\n      pending = {\n        \"this\": this,\n        args: args\n      };\n      startTimer();\n    }\n  }\n  // Prevents delayed function from execution when no longer needed.\n  throttled.cancel = function () {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    pending = null;\n    lastInvokeTime = null;\n    timerId = null;\n  };\n  return throttled;\n}\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid(series) {\n  var _a;\n  var sampleXValues = getXValues(series);\n  for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {\n    var s = series_2[_i];\n    if (s.type === 'area') {\n      for (var i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (((_a = s.data[i]) === null || _a === void 0 ? void 0 : _a.x) !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues(series) {\n  for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {\n    var s = series_3[_i];\n    if (s.type === 'area') {\n      return s.data.map(function (_a) {\n        var x = _a.x;\n        return x;\n      });\n    }\n  }\n  return [];\n}\n// Returns data that is visible in the given scale.\nfunction getVisibleData(data, xScale) {\n  var scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var visibleData = [];\n  for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n    var x = data_1[_i];\n    var scaledX = xScale.d3Scale(x);\n    if (scaledX !== undefined) {\n      visibleData.push({\n        x: x,\n        scaledX: scaledX + scaledOffsetX\n      });\n    }\n  }\n  return visibleData;\n}\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix(matrix, row, col, value) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n// Creates new array with only unique elements of the given array.\nfunction uniq(arr) {\n  var set = new Set();\n  var uniqArray = [];\n  for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {\n    var value = arr_1[_i];\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n  return uniqArray;\n}","map":{"version":3,"mappings":"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","names":["EPSILON","computeDomainX","series","xValues","getXValues","length","uniq","reduce","_a","x","min","max","computeDomainY","scaleType","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","forEach","s","type","Math","y","_","xIndex","stackY","series_1","_i","data","computePlotPoints","xScale","yScale","xy","xs","sx","getVisibleData","scaledX","points","sIndex","scaledY","d3Scale","push","y0","y1","scaled","index","value","sort","p1","p2","point","insertIntoMatrix","findClosest","sortedArray","target","getter","Error","isAscending","compare","delta","abs","lo","hi","mid","floor","circleIndex","from","to","throttle","func","delay","pending","lastInvokeTime","timerId","pendingFunc","time","Date","now","shouldInvoke","apply","args","startTimer","cancelAnimationFrame","requestAnimationFrame","throttled","cancel","isSeriesValid","sampleXValues","series_2","i","series_3","map","scaledOffsetX","isCategorical","bandwidth","visibleData","data_1","undefined","matrix","row","col","arr","set","Set","uniqArray","arr_1","has","add"],"sources":["/Users/dcastro/node_modules/src/area-chart/model/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { AreaChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { ChartDataTypes, XDomain, YDomain, YScaleType } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartModel } from './index';\n\ninterface ThrottledFunction<F extends (...args: any) => any> {\n  (...args: Parameters<F>): void;\n  cancel(): void;\n}\n\n// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX<T extends ChartDataTypes>(series: readonly AreaChartProps.Series<T>[]): XDomain<T> {\n  const xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [] as unknown as XDomain<T>;\n  }\n\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues) as unknown as XDomain<T>;\n  }\n\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(\n    ([min, max], x) => [x < min ? x : min, max < x ? x : max],\n    [xValues[0], xValues[0]]\n  ) as unknown as XDomain<T>;\n}\n\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY<T>(series: readonly AreaChartProps.Series<T>[], scaleType: YScaleType): YDomain {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (s.data[xIndex]?.y || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n}\n\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints<T>(\n  series: readonly AreaChartProps.Series<T>[],\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): {\n  xy: ChartModel.PlotPoint<T>[][];\n  xs: ChartModel.PlotPoint<T>[][];\n  sx: ChartModel.PlotPoint<T>[][];\n} {\n  const xValues = getXValues(series);\n\n  // Lookup for xy[xIndex][yIndex]\n  const xy: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx: ChartModel.PlotPoint<T>[][] = [];\n\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(({ x, scaledX }, xIndex) => {\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n\n    // A column of series points related to the same x.\n    const points: ChartModel.PlotPoint<T>[] = [];\n\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: { x: scaledX, y0: scaledY, y1: scaledY },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: 0,\n        });\n      } else {\n        const value = s.data[xIndex]?.y || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: { x: scaledX, y0: yScale.d3Scale(y0) || 0, y1: yScale.d3Scale(y1) || 0 },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: value,\n        });\n\n        stackY = y1;\n      }\n    });\n\n    // Sort points by y and insert the missing y-index.\n    points\n      .sort((p1, p2) => p1.y1 - p2.y1)\n      .forEach((point, index) => {\n        point.index.y = index;\n\n        // Insert the points to the respective two-dimensional lookup arrays.\n        insertIntoMatrix(xy, point.index.x, point.index.y, point);\n        insertIntoMatrix(xs, point.index.x, point.index.s, point);\n        insertIntoMatrix(sx, point.index.s, point.index.x, point);\n      });\n  });\n\n  return { xy, xs, sx };\n}\n\n// Finds the closest point in the sorted array.\nexport function findClosest<T>(sortedArray: readonly T[], target: number, getter: (item: T) => number): T {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = (x: T) => (isAscending ? getter(x) < target : getter(x) > target);\n  const delta = (x: T) => Math.abs(getter(x) - target);\n\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nexport function circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n\n// Delays function execution\nexport function throttle<F extends (...args: any) => any>(func: F, delay: number): ThrottledFunction<F> {\n  let pending: null | { this: any; args: any } = null;\n  let lastInvokeTime: null | number = null;\n  let timerId: null | number = null;\n\n  // Runs on every animation frame until timer stopped.\n  function pendingFunc() {\n    if (pending && lastInvokeTime !== null) {\n      const time = Date.now();\n      const shouldInvoke = time - lastInvokeTime >= delay;\n\n      if (shouldInvoke) {\n        func.apply(pending.this, pending.args);\n        lastInvokeTime = time;\n        pending = null;\n      } else {\n        startTimer();\n      }\n    }\n  }\n\n  function startTimer() {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    timerId = requestAnimationFrame(pendingFunc);\n  }\n\n  // Decorated client function with delay mechanism.\n  function throttled(this: any, ...args: any) {\n    if (lastInvokeTime === null) {\n      func.apply(this, args);\n      lastInvokeTime = Date.now();\n    } else {\n      pending = { this: this, args };\n      startTimer();\n    }\n  }\n\n  // Prevents delayed function from execution when no longer needed.\n  throttled.cancel = () => {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    pending = null;\n    lastInvokeTime = null;\n    timerId = null;\n  };\n\n  return throttled;\n}\n\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid<T>(series: readonly AreaChartProps.Series<T>[]) {\n  const sampleXValues = getXValues(series);\n\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (s.data[i]?.x !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues<T>(series: readonly AreaChartProps.Series<T>[]) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(({ x }) => x);\n    }\n  }\n\n  return [];\n}\n\n// Returns data that is visible in the given scale.\nfunction getVisibleData<T>(data: readonly T[], xScale: ChartScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x as any);\n\n    if (scaledX !== undefined) {\n      visibleData.push({ x, scaledX: scaledX + scaledOffsetX });\n    }\n  }\n  return visibleData;\n}\n\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix<T>(matrix: T[][], row: number, col: number, value: T) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n\n// Creates new array with only unique elements of the given array.\nfunction uniq<T>(arr: readonly T[]): readonly T[] {\n  const set = new Set();\n  const uniqArray: T[] = [];\n\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}