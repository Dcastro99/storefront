{"ast":null,"code":"import { isXThreshold, isYThreshold } from './utils';\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries(allSeries, xScale, yScale) {\n  var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var scaleX = function (x) {\n    return (xScale.d3Scale(x) || 0) + xOffset;\n  };\n  var scaleY = function (y) {\n    return yScale.d3Scale(y) || 0;\n  };\n  var allX = getAllX(allSeries);\n  function mergeLineSeriesPointsWithXThresholds(scaledPoints, xThresholdSeries, xThresholdSeriesColor) {\n    var _a, _b;\n    var x = scaleX(xThresholdSeries.x);\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    var bisectIndex = -1;\n    for (var i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      var prevY = ((_a = scaledPoints[bisectIndex].datum) === null || _a === void 0 ? void 0 : _a.y) || 0;\n      var nextY = ((_b = scaledPoints[bisectIndex + 1].datum) === null || _b === void 0 ? void 0 : _b.y) || 0;\n      var averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: {\n          x: xThresholdSeries.x,\n          y: NaN\n        },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor\n      });\n    }\n  }\n  var scaledSeriesX = allSeries.map(function (_a) {\n    var series = _a.series,\n      color = _a.color;\n    var scaledPoints = [];\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (var _i = 0, _b = series.data; _i < _b.length; _i++) {\n        var datum = _b[_i];\n        scaledPoints.push({\n          x: scaleX(datum.x),\n          y: scaleY(datum.y),\n          datum: datum,\n          series: series,\n          color: color\n        });\n      }\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort(function (s1, s2) {\n        return s1.x - s2.x;\n      });\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (var _c = 0, allSeries_1 = allSeries; _c < allSeries_1.length; _c++) {\n        var otherSeries = allSeries_1[_c];\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (var _d = 0, allX_1 = allX; _d < allX_1.length; _d++) {\n        var x = allX_1[_d];\n        scaledPoints.push({\n          x: scaleX(x),\n          y: scaleY(series.y),\n          datum: {\n            x: x,\n            y: series.y\n          },\n          series: series,\n          color: color\n        });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({\n          x: NaN,\n          y: scaleY(series.y),\n          series: series,\n          color: color\n        });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({\n        x: scaleX(series.x),\n        y: NaN,\n        datum: {\n          x: series.x,\n          y: NaN\n        },\n        series: series,\n        color: color\n      });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort(function (s1, s2) {\n    return s1.x - s2.x;\n  });\n}\n/** Collect unique x values from all data series. */\nfunction getAllX(series) {\n  var addDataXSet = new Set();\n  for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n    var s = series_1[_i].series;\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (var _a = 0, _b = s.data; _a < _b.length; _a++) {\n          var d = _b[_a];\n          addDataXSet.add(d.x);\n        }\n        break;\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  var allDataX = [];\n  addDataXSet.forEach(function (x) {\n    return allDataX.push(x);\n  });\n  return allDataX;\n}\nfunction flatten(arrays) {\n  var merged = [];\n  for (var _i = 0, arrays_1 = arrays; _i < arrays_1.length; _i++) {\n    var array = arrays_1[_i];\n    for (var _a = 0, array_1 = array; _a < array_1.length; _a++) {\n      var item = array_1[_a];\n      merged.push(item);\n    }\n  }\n  return merged;\n}","map":{"version":3,"mappings":"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","names":["isXThreshold","isYThreshold","makeScaledSeries","allSeries","xScale","yScale","xOffset","isCategorical","Math","max","d3Scale","bandwidth","scaleX","x","scaleY","y","allX","getAllX","mergeLineSeriesPointsWithXThresholds","scaledPoints","xThresholdSeries","xThresholdSeriesColor","bisectIndex","i","length","prevY","datum","nextY","averageY","push","NaN","series","color","scaledSeriesX","map","_a","type","_b","data","_i","sort","s1","s2","allSeries_1","_c","otherSeries","allX_1","_d","flatten","addDataXSet","Set","series_1","s","d","add","allDataX","forEach","arrays","merged","arrays_1","array","array_1","item"],"sources":["/Users/dcastro/node_modules/src/mixed-line-bar-chart/make-scaled-series.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { isXThreshold, isYThreshold } from './utils';\n\nexport interface ScaledPoint<T> {\n  x: number;\n  y: number;\n  color: string;\n  datum?: MixedLineBarChartProps.Datum<T> | undefined;\n  series: MixedLineBarChartProps.ChartSeries<T>;\n}\n\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries<T extends ChartDataTypes>(\n  allSeries: ReadonlyArray<InternalChartSeries<T>>,\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): readonly ScaledPoint<T>[] {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = (x: T) => (xScale.d3Scale(x as any) || 0) + xOffset;\n  const scaleY = (y: number) => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n\n  function mergeLineSeriesPointsWithXThresholds(\n    scaledPoints: ScaledPoint<T>[],\n    xThresholdSeries: MixedLineBarChartProps.ThresholdSeries<T> & { x: T },\n    xThresholdSeriesColor: string\n  ) {\n    const x = scaleX(xThresholdSeries.x);\n\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = scaledPoints[bisectIndex].datum?.y || 0;\n      const nextY = scaledPoints[bisectIndex + 1].datum?.y || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: { x: xThresholdSeries.x, y: NaN },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor,\n      });\n    }\n  }\n\n  const scaledSeriesX = allSeries.map(({ series, color }) => {\n    const scaledPoints: ScaledPoint<T>[] = [];\n\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data as MixedLineBarChartProps.Datum<T>[]) {\n        scaledPoints.push({ x: scaleX(datum.x), y: scaleY(datum.y), datum, series, color });\n      }\n\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({ x: scaleX(x), y: scaleY(series.y), datum: { x, y: series.y }, series, color });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({ x: NaN, y: scaleY(series.y), series, color });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({ x: scaleX(series.x), y: NaN, datum: { x: series.x, y: NaN }, series, color });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n\n/** Collect unique x values from all data series. */\nfunction getAllX<T>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const addDataXSet = new Set<T>();\n  for (const { series: s } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX: T[] = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n\n  return allDataX;\n}\n\nfunction flatten<T>(arrays: T[][]): T[] {\n  const merged: T[] = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}