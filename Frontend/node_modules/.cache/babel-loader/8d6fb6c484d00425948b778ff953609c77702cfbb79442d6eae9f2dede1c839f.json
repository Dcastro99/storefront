{"ast":null,"code":"import { __assign } from \"tslib\";\nimport styles from './styles.css.js';\nexport var dimensionsBySize = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: 8,\n    padding: 8,\n    paddingLabels: 44\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: 12,\n    padding: 12,\n    paddingLabels: 44\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: 12,\n    padding: 12,\n    paddingLabels: 44\n  }\n};\nexport var refreshDimensionsBySize = {\n  small: __assign(__assign({}, dimensionsBySize.small), {\n    innerRadius: 38,\n    cornerRadius: 3\n  }),\n  medium: __assign(__assign({}, dimensionsBySize.medium), {\n    innerRadius: 75,\n    cornerRadius: 4\n  }),\n  large: __assign(__assign({}, dimensionsBySize.large), {\n    innerRadius: 105,\n    cornerRadius: 5\n  })\n};\nexport var defaultDetails = function (i18nStrings) {\n  return function (datum, dataSum) {\n    return [{\n      key: i18nStrings.detailsValue || '',\n      value: datum.value\n    }, {\n      key: i18nStrings.detailsPercentage || '',\n      value: \"\".concat((datum.value * 100 / dataSum).toFixed(0), \"%\")\n    }];\n  };\n};\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\nexport var balanceLabelNodes = function (nodes, markers, leftSide) {\n  var _a;\n  var MARGIN = 10;\n  var previousBBox = null;\n  // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n  var i = leftSide ? nodes.length - 1 : 0;\n  while (leftSide && i >= 0 || !leftSide && i < nodes.length) {\n    var node = nodes[i];\n    // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n    var x = parseFloat(node.getAttribute('data-x') || '0');\n    var y = parseFloat(node.getAttribute('data-y') || '0');\n    var box = {\n      x: x,\n      y: y,\n      height: node.getBoundingClientRect().height\n    };\n    var marker = markers[i];\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n    if (!leftSide && box.x < 0 || leftSide && box.x >= 0) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n    node.setAttribute('transform', '');\n    // Calculate how much the current node is overlapping with the previous one.\n    var offset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n    if (offset > 0) {\n      // Move the label down.\n      node.setAttribute('transform', \"translate(0 \".concat(offset, \")\"));\n      // Adjust the attached line accordingly.\n      var lineNode = (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(styles['label-line']));\n      if (lineNode) {\n        var endY = marker.endY;\n        lineNode.setAttribute('y2', '' + (endY + offset));\n      }\n      // Update the position accordingly to inform the next label\n      box.y += offset;\n    }\n    previousBBox = box;\n  }\n};","map":{"version":3,"mappings":"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","names":["styles","dimensionsBySize","small","innerRadius","outerRadius","innerLabelPadding","padding","paddingLabels","medium","large","refreshDimensionsBySize","cornerRadius","defaultDetails","i18nStrings","datum","dataSum","key","detailsValue","value","detailsPercentage","toFixed","balanceLabelNodes","nodes","markers","leftSide","MARGIN","previousBBox","i","length","node","x","parseFloat","getAttribute","y","box","height","getBoundingClientRect","marker","setAttribute","offset","lineNode","parentNode","querySelector","endY"],"sources":["/Users/dcastro/node_modules/src/pie-chart/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PieChartProps } from './interfaces';\nimport styles from './styles.css.js';\n\ninterface Dimension {\n  innerRadius: number;\n  outerRadius: number;\n  padding: number;\n  paddingLabels: number;\n  innerLabelPadding: number;\n  cornerRadius?: number;\n}\n\nexport const dimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: 8,\n    padding: 8, // = space-xs\n    paddingLabels: 44, // = 2 * (size-lineHeight-body-100)\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: 12,\n    padding: 12, // = space-s\n    paddingLabels: 44, // = 2 * (size-lineHeight-body-100)\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: 12,\n    padding: 12, // = space-s\n    paddingLabels: 44, // = 2 * (size-lineHeight-body-100)\n  },\n};\n\nexport const refreshDimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    ...dimensionsBySize.small,\n    innerRadius: 38,\n    cornerRadius: 3,\n  },\n  medium: {\n    ...dimensionsBySize.medium,\n    innerRadius: 75,\n    cornerRadius: 4,\n  },\n  large: {\n    ...dimensionsBySize.large,\n    innerRadius: 105,\n    cornerRadius: 5,\n  },\n};\n\nexport const defaultDetails =\n  (i18nStrings: PieChartProps.I18nStrings) => (datum: PieChartProps.Datum, dataSum: number) =>\n    [\n      { key: i18nStrings.detailsValue || '', value: datum.value },\n      {\n        key: i18nStrings.detailsPercentage || '',\n        value: `${((datum.value * 100) / dataSum).toFixed(0)}%`,\n      },\n    ];\n\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\nexport const balanceLabelNodes = (\n  nodes: NodeListOf<SVGGElement>,\n  markers: Array<{ endY: number }>,\n  leftSide: boolean\n) => {\n  const MARGIN = 10;\n\n  let previousBBox: { x: number; y: number; height: number } | null = null;\n\n  // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n  let i = leftSide ? nodes.length - 1 : 0;\n\n  while ((leftSide && i >= 0) || (!leftSide && i < nodes.length)) {\n    const node = nodes[i];\n\n    // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n    const x = parseFloat(node.getAttribute('data-x') || '0');\n    const y = parseFloat(node.getAttribute('data-y') || '0');\n    const box = {\n      x,\n      y,\n      height: node.getBoundingClientRect().height,\n    };\n\n    const marker = markers[i];\n\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n\n    if ((!leftSide && box.x < 0) || (leftSide && box.x >= 0)) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n\n    node.setAttribute('transform', '');\n\n    // Calculate how much the current node is overlapping with the previous one.\n    const offset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n\n    if (offset > 0) {\n      // Move the label down.\n      node.setAttribute('transform', `translate(0 ${offset})`);\n\n      // Adjust the attached line accordingly.\n      const lineNode = node.parentNode?.querySelector(`.${styles['label-line']}`);\n      if (lineNode) {\n        const { endY } = marker;\n        lineNode.setAttribute('y2', '' + (endY + offset));\n      }\n\n      // Update the position accordingly to inform the next label\n      box.y += offset;\n    }\n\n    previousBBox = box;\n  }\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}