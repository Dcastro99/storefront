{"ast":null,"code":"var BREAKPOINT_MAPPING = [['xl', 1840], ['l', 1320], ['m', 1120], ['s', 912], ['xs', 688], ['xxs', 465], ['default', -1]];\nexport var mobileBreakpoint = BREAKPOINT_MAPPING.filter(function (b) {\n  return b[0] === 'xs';\n})[0][1];\nvar BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(function (_a) {\n  var bp = _a[0];\n  return bp;\n});\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping(subset, actual) {\n  var qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (var _i = 0, qualifyingBreakpoints_1 = qualifyingBreakpoints; _i < qualifyingBreakpoints_1.length; _i++) {\n    var breakpoint = qualifyingBreakpoints_1[_i][0];\n    var breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width, breakpointFilter) {\n  for (var _i = 0, BREAKPOINT_MAPPING_1 = BREAKPOINT_MAPPING; _i < BREAKPOINT_MAPPING_1.length; _i++) {\n    var _a = BREAKPOINT_MAPPING_1[_i],\n      breakpoint = _a[0],\n      breakpointWidth = _a[1];\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}","map":{"version":3,"mappings":"AAIA,IAAMA,kBAAkB,GAA2B,CACjD,CAAC,IAAI,EAAE,IAAI,CAAC,EACZ,CAAC,GAAG,EAAE,IAAI,CAAC,EACX,CAAC,GAAG,EAAE,IAAI,CAAC,EACX,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,IAAI,EAAE,GAAG,CAAC,EACX,CAAC,KAAK,EAAE,GAAG,CAAC,EACZ,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAChB;AAED,OAAO,IAAMC,gBAAgB,GAAGD,kBAAkB,CAACE,MAAM,CAAC,WAAC;EAAI,QAAC,CAAC,CAAC,CAAC,KAAK,IAAI;AAAb,CAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAEnF,IAAMC,sBAAsB,GAAGH,kBAAkB,CAACI,GAAG,CAAC,UAACC,EAAI;MAAHC,EAAE;EAAM,SAAE;AAAF,CAAE,CAAC;AAEnE;;;AAGA,OAAM,SAAUC,sBAAsB,CAAIC,MAAsC,EAAEC,MAAkB;EAClG,IAAMC,qBAAqB,GAAGV,kBAAkB,CAACW,KAAK,CAACR,sBAAsB,CAACS,OAAO,CAACH,MAAM,CAAC,CAAC;EAC9F,KAA2B,UAAqB,EAArBI,+CAAqB,EAArBC,mCAAqB,EAArBA,IAAqB,EAAE;IAAtC,cAAU;IACpB,IAAMC,eAAe,GAAGP,MAAM,CAACQ,UAAU,CAAC;IAC1C,IAAID,eAAe,KAAKE,SAAS,EAAE;MACjC,OAAOF,eAAe;;;EAG1B,OAAO,IAAI;AACb;AAEA;;;AAGA,OAAM,SAAUG,qBAAqB,CAACC,KAAa,EAAEC,gBAAwC;EAC3F,KAA4C,UAAkB,EAAlBC,yCAAkB,EAAlBP,gCAAkB,EAAlBA,IAAkB,EAAE;IAArD,iCAA6B;MAA5BE,UAAU;MAAEM,eAAe;IACrC,IAAIH,KAAK,GAAGG,eAAe,KAAK,CAACF,gBAAgB,IAAIA,gBAAgB,CAACR,OAAO,CAACI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;MACjG,OAAOA,UAAU;;;EAGrB,OAAO,SAAS;AAClB","names":["BREAKPOINT_MAPPING","mobileBreakpoint","filter","BREAKPOINTS_DESCENDING","map","_a","bp","matchBreakpointMapping","subset","actual","qualifyingBreakpoints","slice","indexOf","qualifyingBreakpoints_1","_i","breakpointValue","breakpoint","undefined","getMatchingBreakpoint","width","breakpointFilter","BREAKPOINT_MAPPING_1","breakpointWidth"],"sources":["/Users/dcastro/node_modules/src/internal/breakpoints.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport type Breakpoint = 'default' | 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl';\n\nconst BREAKPOINT_MAPPING: [Breakpoint, number][] = [\n  ['xl', 1840],\n  ['l', 1320],\n  ['m', 1120],\n  ['s', 912],\n  ['xs', 688],\n  ['xxs', 465],\n  ['default', -1],\n];\n\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\n\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(([bp]) => bp);\n\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping<T>(subset: Partial<Record<Breakpoint, T>>, actual: Breakpoint): T | null {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width: number, breakpointFilter?: readonly Breakpoint[]): Breakpoint {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}