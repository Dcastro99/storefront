{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useStableEventHandler } from '../../internal/hooks/use-stable-event-handler';\nimport { getOverflowParents } from '../../internal/utils/scrollable-containers';\nimport { findUpUntil } from '../../internal/utils/dom';\nimport tableStyles from '../styles.css.js';\nimport styles from './styles.css.js';\nvar AUTO_GROW_START_TIME = 10;\nvar AUTO_GROW_INTERVAL = 10;\nvar AUTO_GROW_INCREMENT = 5;\nexport function Resizer(_a) {\n  var onDragMove = _a.onDragMove,\n    onFinish = _a.onFinish;\n  var _b = useState(false),\n    isDragging = _b[0],\n    setIsDragging = _b[1];\n  var _c = useState(),\n    headerCell = _c[0],\n    setHeaderCell = _c[1];\n  var autoGrowTimeout = useRef();\n  var onFinishStable = useStableEventHandler(onFinish);\n  var onDragStable = useStableEventHandler(onDragMove);\n  useEffect(function () {\n    if (!isDragging || !headerCell) {\n      return;\n    }\n    var rootElement = findUpUntil(headerCell, function (element) {\n      return element.className.indexOf(tableStyles.root) > -1;\n    });\n    var tableElement = rootElement.querySelector(\"table\");\n    // tracker is rendered inside table wrapper to align with its size\n    var tracker = rootElement.querySelector(\".\".concat(styles.tracker));\n    var scrollParent = getOverflowParents(headerCell)[0];\n    var _a = scrollParent.getBoundingClientRect(),\n      leftEdge = _a.left,\n      rightEdge = _a.right;\n    var updateTrackerPosition = function (newOffset) {\n      var scrollParentLeft = tableElement.getBoundingClientRect().left;\n      tracker.style.top = headerCell.getBoundingClientRect().height + 'px';\n      // minus one pixel to offset the cell border\n      tracker.style.left = newOffset - scrollParentLeft - 1 + 'px';\n    };\n    var updateColumnWidth = function (newWidth) {\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      onDragStable(newWidth);\n      // we read the element size again because the previous callback changes it\n      updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    };\n    var resizeColumn = function (offset) {\n      if (offset > leftEdge) {\n        var cellLeft = headerCell.getBoundingClientRect().left;\n        var newWidth = offset - cellLeft;\n        // callbacks must be the last calls in the handler, because they may cause an extra update\n        updateColumnWidth(newWidth);\n      }\n    };\n    var onAutoGrow = function () {\n      var width = headerCell.getBoundingClientRect().width;\n      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      updateColumnWidth(width + AUTO_GROW_INCREMENT);\n      scrollParent.scrollLeft += AUTO_GROW_INCREMENT;\n    };\n    var onMouseMove = function (event) {\n      clearTimeout(autoGrowTimeout.current);\n      var offset = event.pageX;\n      if (offset > rightEdge) {\n        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);\n      } else {\n        resizeColumn(offset);\n      }\n    };\n    var onMouseUp = function (event) {\n      resizeColumn(event.pageX);\n      setIsDragging(false);\n      onFinishStable();\n      clearTimeout(autoGrowTimeout.current);\n    };\n    updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    document.body.classList.add(styles['resize-active']);\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    return function () {\n      clearTimeout(autoGrowTimeout.current);\n      document.body.classList.remove(styles['resize-active']);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [headerCell, isDragging, onDragStable, onFinishStable]);\n  return React.createElement(\"span\", {\n    className: clsx(styles.resizer, isDragging && styles['resizer-active']),\n    onMouseDown: function (event) {\n      if (event.button !== 0) {\n        return;\n      }\n      event.preventDefault();\n      var headerCell = findUpUntil(event.currentTarget, function (element) {\n        return element.tagName.toLowerCase() === 'th';\n      });\n      setIsDragging(true);\n      setHeaderCell(headerCell);\n    }\n  });\n}\nexport function ResizeTracker() {\n  return React.createElement(\"span\", {\n    className: styles.tracker\n  });\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAOA,IAAI,MAAM,MAAM;AACvB,OAAOC,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,SAASC,qBAAqB,QAAQ,+CAA+C;AACrF,SAASC,kBAAkB,QAAQ,4CAA4C;AAC/E,SAASC,WAAW,QAAQ,0BAA0B;AACtD,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,OAAOC,MAAM,MAAM,iBAAiB;AAOpC,IAAMC,oBAAoB,GAAG,EAAE;AAC/B,IAAMC,kBAAkB,GAAG,EAAE;AAC7B,IAAMC,mBAAmB,GAAG,CAAC;AAE7B,OAAM,SAAUC,OAAO,CAACC,EAAsC;MAApCC,UAAU;IAAEC,QAAQ;EACtC,SAA8BZ,QAAQ,CAAC,KAAK,CAAC;IAA5Ca,UAAU;IAAEC,aAAa,QAAmB;EAC7C,SAA8Bd,QAAQ,EAAe;IAApDe,UAAU;IAAEC,aAAa,QAA2B;EAC3D,IAAMC,eAAe,GAAGlB,MAAM,EAA6C;EAC3E,IAAMmB,cAAc,GAAGjB,qBAAqB,CAACW,QAAQ,CAAC;EACtD,IAAMO,YAAY,GAAGlB,qBAAqB,CAACU,UAAU,CAAC;EACtDb,SAAS,CAAC;IACR,IAAI,CAACe,UAAU,IAAI,CAACE,UAAU,EAAE;MAC9B;;IAEF,IAAMK,WAAW,GAAGjB,WAAW,CAACY,UAAU,EAAE,iBAAO;MAAI,cAAO,CAACM,SAAS,CAACC,OAAO,CAAClB,WAAW,CAACmB,IAAI,CAAC,GAAG,CAAC,CAAC;IAAhD,CAAgD,CAAE;IACzG,IAAMC,YAAY,GAAGJ,WAAW,CAACK,aAAa,CAAc,OAAO,CAAE;IACrE;IACA,IAAMC,OAAO,GAAGN,WAAW,CAACK,aAAa,CAAc,WAAIpB,MAAM,CAACqB,OAAO,CAAE,CAAE;IAC7E,IAAMC,YAAY,GAAGzB,kBAAkB,CAACa,UAAU,CAAC,CAAC,CAAC,CAAC;IAChD,SAAuCY,YAAY,CAACC,qBAAqB,EAAE;MAAnEC,QAAQ;MAASC,SAAS,WAAyC;IAEjF,IAAMC,qBAAqB,GAAG,UAACC,SAAiB;MACtC,IAAMC,gBAAgB,GAAKT,YAAY,CAACI,qBAAqB,EAAE,KAAzC;MAC9BF,OAAO,CAACQ,KAAK,CAACC,GAAG,GAAGpB,UAAU,CAACa,qBAAqB,EAAE,CAACQ,MAAM,GAAG,IAAI;MACpE;MACAV,OAAO,CAACQ,KAAK,CAACG,IAAI,GAAGL,SAAS,GAAGC,gBAAgB,GAAG,CAAC,GAAG,IAAI;IAC9D,CAAC;IAED,IAAMK,iBAAiB,GAAG,UAACC,QAAgB;MACzC;MACApB,YAAY,CAACoB,QAAQ,CAAC;MACtB;MACAR,qBAAqB,CAAChB,UAAU,CAACa,qBAAqB,EAAE,CAACY,KAAK,CAAC;IACjE,CAAC;IAED,IAAMC,YAAY,GAAG,UAACC,MAAc;MAClC,IAAIA,MAAM,GAAGb,QAAQ,EAAE;QACrB,IAAMc,QAAQ,GAAG5B,UAAU,CAACa,qBAAqB,EAAE,CAACS,IAAI;QACxD,IAAME,QAAQ,GAAGG,MAAM,GAAGC,QAAQ;QAClC;QACAL,iBAAiB,CAACC,QAAQ,CAAC;;IAE/B,CAAC;IAED,IAAMK,UAAU,GAAG;MACjB,IAAMC,KAAK,GAAG9B,UAAU,CAACa,qBAAqB,EAAE,CAACiB,KAAK;MACtD5B,eAAe,CAAC6B,OAAO,GAAGC,UAAU,CAACH,UAAU,EAAErC,kBAAkB,CAAC;MACpE;MACA+B,iBAAiB,CAACO,KAAK,GAAGrC,mBAAmB,CAAC;MAC9CmB,YAAY,CAACqB,UAAU,IAAIxC,mBAAmB;IAChD,CAAC;IACD,IAAMyC,WAAW,GAAG,UAACC,KAAiB;MACpCC,YAAY,CAAClC,eAAe,CAAC6B,OAAO,CAAC;MACrC,IAAMJ,MAAM,GAAGQ,KAAK,CAACE,KAAK;MAC1B,IAAIV,MAAM,GAAGZ,SAAS,EAAE;QACtBb,eAAe,CAAC6B,OAAO,GAAGC,UAAU,CAACH,UAAU,EAAEtC,oBAAoB,CAAC;OACvE,MAAM;QACLmC,YAAY,CAACC,MAAM,CAAC;;IAExB,CAAC;IACD,IAAMW,SAAS,GAAG,UAACH,KAAiB;MAClCT,YAAY,CAACS,KAAK,CAACE,KAAK,CAAC;MACzBtC,aAAa,CAAC,KAAK,CAAC;MACpBI,cAAc,EAAE;MAChBiC,YAAY,CAAClC,eAAe,CAAC6B,OAAO,CAAC;IACvC,CAAC;IACDf,qBAAqB,CAAChB,UAAU,CAACa,qBAAqB,EAAE,CAACY,KAAK,CAAC;IAC/Dc,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACC,GAAG,CAACpD,MAAM,CAAC,eAAe,CAAC,CAAC;IACpDiD,QAAQ,CAACI,gBAAgB,CAAC,WAAW,EAAET,WAAW,CAAC;IACnDK,QAAQ,CAACI,gBAAgB,CAAC,SAAS,EAAEL,SAAS,CAAC;IAC/C,OAAO;MACLF,YAAY,CAAClC,eAAe,CAAC6B,OAAO,CAAC;MACrCQ,QAAQ,CAACC,IAAI,CAACC,SAAS,CAACG,MAAM,CAACtD,MAAM,CAAC,eAAe,CAAC,CAAC;MACvDiD,QAAQ,CAACM,mBAAmB,CAAC,WAAW,EAAEX,WAAW,CAAC;MACtDK,QAAQ,CAACM,mBAAmB,CAAC,SAAS,EAAEP,SAAS,CAAC;IACpD,CAAC;EACH,CAAC,EAAE,CAACtC,UAAU,EAAEF,UAAU,EAAEM,YAAY,EAAED,cAAc,CAAC,CAAC;EAC1D,OACErB;IACEwB,SAAS,EAAEzB,IAAI,CAACS,MAAM,CAACwD,OAAO,EAAEhD,UAAU,IAAIR,MAAM,CAAC,gBAAgB,CAAC,CAAC;IACvEyD,WAAW,EAAE,eAAK;MAChB,IAAIZ,KAAK,CAACa,MAAM,KAAK,CAAC,EAAE;QACtB;;MAEFb,KAAK,CAACc,cAAc,EAAE;MACtB,IAAMjD,UAAU,GAAGZ,WAAW,CAAC+C,KAAK,CAACe,aAAa,EAAE,iBAAO;QAAI,cAAO,CAACC,OAAO,CAACC,WAAW,EAAE,KAAK,IAAI;MAAtC,CAAsC,CAAE;MACvGrD,aAAa,CAAC,IAAI,CAAC;MACnBE,aAAa,CAACD,UAAU,CAAC;IAC3B;EAAC,EACD;AAEN;AAEA,OAAM,SAAUqD,aAAa;EAC3B,OAAOvE;IAAMwB,SAAS,EAAEhB,MAAM,CAACqB;EAAO,EAAI;AAC5C","names":["clsx","React","useEffect","useRef","useState","useStableEventHandler","getOverflowParents","findUpUntil","tableStyles","styles","AUTO_GROW_START_TIME","AUTO_GROW_INTERVAL","AUTO_GROW_INCREMENT","Resizer","_a","onDragMove","onFinish","isDragging","setIsDragging","headerCell","setHeaderCell","autoGrowTimeout","onFinishStable","onDragStable","rootElement","className","indexOf","root","tableElement","querySelector","tracker","scrollParent","getBoundingClientRect","leftEdge","rightEdge","updateTrackerPosition","newOffset","scrollParentLeft","style","top","height","left","updateColumnWidth","newWidth","right","resizeColumn","offset","cellLeft","onAutoGrow","width","current","setTimeout","scrollLeft","onMouseMove","event","clearTimeout","pageX","onMouseUp","document","body","classList","add","addEventListener","remove","removeEventListener","resizer","onMouseDown","button","preventDefault","currentTarget","tagName","toLowerCase","ResizeTracker"],"sources":["/Users/dcastro/node_modules/src/table/resizer/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport clsx from 'clsx';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useStableEventHandler } from '../../internal/hooks/use-stable-event-handler';\nimport { getOverflowParents } from '../../internal/utils/scrollable-containers';\nimport { findUpUntil } from '../../internal/utils/dom';\nimport tableStyles from '../styles.css.js';\nimport styles from './styles.css.js';\n\ninterface ResizerProps {\n  onDragMove: (newWidth: number) => void;\n  onFinish: () => void;\n}\n\nconst AUTO_GROW_START_TIME = 10;\nconst AUTO_GROW_INTERVAL = 10;\nconst AUTO_GROW_INCREMENT = 5;\n\nexport function Resizer({ onDragMove, onFinish }: ResizerProps) {\n  const [isDragging, setIsDragging] = useState(false);\n  const [headerCell, setHeaderCell] = useState<HTMLElement>();\n  const autoGrowTimeout = useRef<ReturnType<typeof setTimeout> | undefined>();\n  const onFinishStable = useStableEventHandler(onFinish);\n  const onDragStable = useStableEventHandler(onDragMove);\n  useEffect(() => {\n    if (!isDragging || !headerCell) {\n      return;\n    }\n    const rootElement = findUpUntil(headerCell, element => element.className.indexOf(tableStyles.root) > -1)!;\n    const tableElement = rootElement.querySelector<HTMLElement>(`table`)!;\n    // tracker is rendered inside table wrapper to align with its size\n    const tracker = rootElement.querySelector<HTMLElement>(`.${styles.tracker}`)!;\n    const scrollParent = getOverflowParents(headerCell)[0];\n    const { left: leftEdge, right: rightEdge } = scrollParent.getBoundingClientRect();\n\n    const updateTrackerPosition = (newOffset: number) => {\n      const { left: scrollParentLeft } = tableElement.getBoundingClientRect();\n      tracker.style.top = headerCell.getBoundingClientRect().height + 'px';\n      // minus one pixel to offset the cell border\n      tracker.style.left = newOffset - scrollParentLeft - 1 + 'px';\n    };\n\n    const updateColumnWidth = (newWidth: number) => {\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      onDragStable(newWidth);\n      // we read the element size again because the previous callback changes it\n      updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    };\n\n    const resizeColumn = (offset: number) => {\n      if (offset > leftEdge) {\n        const cellLeft = headerCell.getBoundingClientRect().left;\n        const newWidth = offset - cellLeft;\n        // callbacks must be the last calls in the handler, because they may cause an extra update\n        updateColumnWidth(newWidth);\n      }\n    };\n\n    const onAutoGrow = () => {\n      const width = headerCell.getBoundingClientRect().width;\n      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);\n      // callbacks must be the last calls in the handler, because they may cause an extra update\n      updateColumnWidth(width + AUTO_GROW_INCREMENT);\n      scrollParent.scrollLeft += AUTO_GROW_INCREMENT;\n    };\n    const onMouseMove = (event: MouseEvent) => {\n      clearTimeout(autoGrowTimeout.current);\n      const offset = event.pageX;\n      if (offset > rightEdge) {\n        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);\n      } else {\n        resizeColumn(offset);\n      }\n    };\n    const onMouseUp = (event: MouseEvent) => {\n      resizeColumn(event.pageX);\n      setIsDragging(false);\n      onFinishStable();\n      clearTimeout(autoGrowTimeout.current);\n    };\n    updateTrackerPosition(headerCell.getBoundingClientRect().right);\n    document.body.classList.add(styles['resize-active']);\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      clearTimeout(autoGrowTimeout.current);\n      document.body.classList.remove(styles['resize-active']);\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [headerCell, isDragging, onDragStable, onFinishStable]);\n  return (\n    <span\n      className={clsx(styles.resizer, isDragging && styles['resizer-active'])}\n      onMouseDown={event => {\n        if (event.button !== 0) {\n          return;\n        }\n        event.preventDefault();\n        const headerCell = findUpUntil(event.currentTarget, element => element.tagName.toLowerCase() === 'th')!;\n        setIsDragging(true);\n        setHeaderCell(headerCell);\n      }}\n    />\n  );\n}\n\nexport function ResizeTracker() {\n  return <span className={styles.tracker} />;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}